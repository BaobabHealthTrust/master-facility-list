/**
 * Bundle of @devexpress/dx-grid-core
 * Generated: 2019-05-17
 * Version: 1.11.0
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@devexpress/dx-core')) :
  typeof define === 'function' && define.amd ? define(['exports', '@devexpress/dx-core'], factory) :
  (global = global || self, factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXGridCore = {}), global.DevExpress.DXCore));
}(this, function (exports, dxCore) { 'use strict';

  if (typeof process === "undefined") { var process = { env: {} }; }

  var GRID_GROUP_TYPE = Symbol('group');
  var GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + "_check");
  var GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + "_levelKey");
  var GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + "_collapsedRows");

  var warnIfRowIdUndefined = function (getRowId) { return function (row) {
      var result = getRowId(row);
      if (!row[GRID_GROUP_CHECK] && result === undefined) {
          // tslint:disable-next-line: no-console
          console.warn('The row id is undefined. Check the getRowId function. The row is', row);
      }
      return result;
  }; };
  var rowIdGetter = function (getRowId, rows) {
      if (!getRowId) {
          var map_1 = new Map(rows.map(function (row, rowIndex) { return [row, rowIndex]; }));
          return function (row) { return map_1.get(row); };
      }
      return warnIfRowIdUndefined(getRowId);
  };
  var defaultGetCellValue = function (row, columnName) { return row[columnName]; };
  var cellValueGetter = function (getCellValue, columns) {
      if (getCellValue === void 0) { getCellValue = defaultGetCellValue; }
      var useFastAccessor = true;
      var map = columns.reduce(function (acc, column) {
          if (column.getCellValue) {
              useFastAccessor = false;
              acc[column.name] = column.getCellValue;
          }
          return acc;
      }, {});
      if (useFastAccessor) {
          return getCellValue;
      }
      return function (row, columnName) { return (map[columnName]
          ? map[columnName](row, columnName)
          : getCellValue(row, columnName)); };
  };

  var changeColumnSorting = function (state, _a) {
      var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;
      var sorting = state.sorting;
      var nextSorting = [];
      if (keepOther === true) {
          nextSorting = sorting;
      }
      if (Array.isArray(keepOther)) {
          nextSorting = dxCore.slice(sorting)
              .filter(function (s) {
              return keepOther.indexOf(s.columnName) > -1;
          });
      }
      var columnSortingIndex = sorting.findIndex(function (s) { return s.columnName === columnName; });
      var columnSorting = sorting[columnSortingIndex];
      var newColumnSorting = {
          columnName: columnName,
          direction: direction
              || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),
      };
      if (columnSortingIndex > -1) {
          nextSorting = dxCore.slice(nextSorting);
          nextSorting.splice(columnSortingIndex, 1);
      }
      if (direction !== null) {
          var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;
          var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;
          nextSorting = dxCore.slice(nextSorting);
          nextSorting.splice(newIndex, 0, newColumnSorting);
      }
      return {
          sorting: nextSorting,
      };
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  var unique = function (arr) { return __spread(Array.from(new Set(arr))); };
  var getColumnSortingDirection = function (sorting, columnName) {
      var columnSorting = sorting.filter(function (s) { return s.columnName === columnName; })[0];
      return columnSorting ? columnSorting.direction : null;
  };
  var getPersistentSortedColumns = function (sorting, columnExtensions) {
      if (columnExtensions === void 0) { columnExtensions = []; }
      return columnExtensions.reduce(function (acc, _a) {
          var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;
          if (sortingEnabled === false) {
              if (sorting.findIndex(function (sortItem) { return sortItem.columnName === columnName; }) > -1) {
                  acc.push(columnName);
              }
          }
          return acc;
      }, []);
  };
  var calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {
      if (persistentSortedColumns === void 0) { persistentSortedColumns = []; }
      if (!persistentSortedColumns.length)
          return keepOther;
      if (!keepOther)
          return persistentSortedColumns;
      return Array.isArray(keepOther)
          ? unique(__spread(keepOther, persistentSortedColumns))
          : unique(__spread(sorting.map(function (item) { return item.columnName; }), persistentSortedColumns));
  };

  /* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */
  /* tslint:disable no-increment-decrement */
  var merge = function (array, auxiliary, lo, mid, hi, compare) {
      var i = lo;
      var j = mid + 1;
      var k = lo;
      while (true) {
          var cmp = compare(array[i], array[j]);
          if (cmp <= 0) {
              auxiliary[k++] = array[i++];
              if (i > mid) {
                  do {
                      auxiliary[k++] = array[j++];
                  } while (j <= hi);
                  break;
              }
          }
          else {
              auxiliary[k++] = array[j++];
              if (j > hi) {
                  do {
                      auxiliary[k++] = array[i++];
                  } while (i <= mid);
                  break;
              }
          }
      }
  };
  var sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {
      if (hi < lo)
          return;
      if (hi === lo) {
          auxiliary[lo] = array[lo];
          return;
      }
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);
      sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);
      merge(array, auxiliary, lo, mid, hi, compare);
  };
  var sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {
      if (hi <= lo)
          return;
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);
      sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);
      merge(auxiliary, array, lo, mid, hi, compare);
  };
  var mergeSort = (function (array, compare) {
      if (compare === void 0) { compare = function (a, b) {
          if (a < b)
              return -1;
          if (a > b)
              return 1;
          return 0;
      }; }
      var result = dxCore.slice(array);
      var auxiliary = dxCore.slice(array);
      sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);
      return result;
  });

  var NODE_CHECK = Symbol('node');
  var rowsToTree = function (rows, getRowLevelKey) {
      if (!rows.length)
          return rows;
      var levels = [{ children: [] }];
      rows.forEach(function (row) {
          var _a;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.slice(1)
                  .findIndex(function (level) { return getRowLevelKey(level.root) === levelKey; }) + 1;
              if (levelIndex > 0) {
                  levels.splice(levelIndex, levels.length - levelIndex);
              }
              var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);
              levels[levels.length - 1].children.push(node);
              levels.push(node);
          }
          else {
              levels[levels.length - 1].children.push(row);
          }
      });
      return levels[0].children;
  };
  var treeToRows = function (tree, rows) {
      if (rows === void 0) { rows = []; }
      if (!tree.length)
          return tree;
      return tree.reduce(function (acc, node) {
          if (node[NODE_CHECK]) {
              acc.push(node.root);
              treeToRows(node.children, rows);
          }
          else {
              acc.push(node);
          }
          return acc;
      }, rows);
  };

  var defaultCompare = function (a, b) {
      if (a === b)
          return 0;
      if (a === null) {
          return b === undefined ? -1 : 1;
      }
      if (a === undefined) {
          return 1;
      }
      if (b === null || b === undefined) {
          return -1;
      }
      return a < b ? -1 : 1;
  };
  var createCompare = function (sorting, getColumnCompare, getComparableValue) { return sorting.reduceRight(function (prevCompare, columnSorting) {
      var columnName = columnSorting.columnName;
      var inverse = columnSorting.direction === 'desc';
      var columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;
      return function (aRow, bRow) {
          var a = getComparableValue(aRow, columnName);
          var b = getComparableValue(bRow, columnName);
          var result = columnCompare(a, b);
          if (result !== 0) {
              return inverse ? -result : result;
          }
          return prevCompare(aRow, bRow);
      };
  }, function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      return 0;
  }); };
  var sortTree = function (tree, compare) {
      var sortedTree = tree.map(function (node) {
          if (node[NODE_CHECK]) {
              return __assign({}, node, { children: sortTree(node.children, compare) });
          }
          return node;
      });
      return mergeSort(sortedTree, function (a, b) { return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b); });
  };
  var sortHierarchicalRows = function (rows, compare, getRowLevelKey) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var sortedTree = sortTree(tree, compare);
      return treeToRows(sortedTree);
  };
  var sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {
      if (!sorting.length || !rows.length)
          return rows;
      var compare;
      if (!getRowLevelKey) {
          compare = createCompare(sorting, getColumnCompare, getCellValue);
          return mergeSort(rows.slice(), compare);
      }
      compare = createCompare(sorting, getColumnCompare, function (row, columnName) {
          if (isGroupRow && isGroupRow(row)) {
              if (row.groupedBy === columnName) {
                  return row.value;
              }
              return undefined;
          }
          return getCellValue(row, columnName);
      });
      return sortHierarchicalRows(rows, compare, getRowLevelKey);
  };

  var changeColumnFilter = function (filters, _a) {
      var columnName = _a.columnName, config = _a.config;
      var filterIndex = filters.findIndex(function (f) { return f.columnName === columnName; });
      var nextState = dxCore.slice(filters);
      if (config) {
          var filter = __assign({ columnName: columnName }, config);
          if (filterIndex > -1) {
              nextState.splice(filterIndex, 1, filter);
          }
          else {
              nextState.push(filter);
          }
      }
      else if (filterIndex > -1) {
          nextState.splice(filterIndex, 1);
      }
      return nextState;
  };

  var getColumnFilterConfig = function (filters, columnName) { return (filters.length && filters.filter(function (s) { return s.columnName === columnName; })[0] || null); };

  var filterExpression = function (filters, expression) {
      // tslint:disable-next-line: no-object-literal-type-assertion
      var selfFilterExpr = { filters: filters, operator: 'and' };
      if (!expression) {
          return selfFilterExpr;
      }
      return {
          operator: 'and',
          filters: [expression, selfFilterExpr],
      };
  };

  var operators = {
      or: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc || predicate(row); }, false)); }; },
      and: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc && predicate(row); }, true)); }; },
  };
  var toLowerCase = function (value) { return String(value).toLowerCase(); };
  var operationPredicates = {
      contains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) > -1; },
      notContains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) === -1; },
      startsWith: function (value, filter) { return toLowerCase(value)
          .startsWith(toLowerCase(filter.value)); },
      endsWith: function (value, filter) { return toLowerCase(value)
          .endsWith(toLowerCase(filter.value)); },
      equal: function (value, filter) { return String(value) === String(filter.value); },
      notEqual: function (value, filter) { return String(value) !== String(filter.value); },
      greaterThan: function (value, filter) { return value > filter.value; },
      greaterThanOrEqual: function (value, filter) { return value >= filter.value; },
      lessThan: function (value, filter) { return value < filter.value; },
      lessThanOrEqual: function (value, filter) { return value <= filter.value; },
  };
  var defaultFilterPredicate = function (value, filter) {
      var operation = filter.operation || 'contains';
      return operationPredicates[operation](value, filter);
  };
  var filterTree = function (tree, predicate) { return tree.reduce(function (acc, node) {
      if (node[NODE_CHECK]) {
          var filteredChildren = filterTree(node.children, predicate);
          if (filteredChildren.length > 0) {
              acc.push(__assign({}, node, { children: filteredChildren }));
              return acc;
          }
          if (predicate(node.root, true)) {
              acc.push(node.root);
              return acc;
          }
          return acc;
      }
      if (predicate(node)) {
          acc.push(node);
          return acc;
      }
      return acc;
  }, []); };
  var filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var collapsedRowsMeta = [];
      var filteredTree = filterTree(tree, function (row, isNode) {
          if (isNode) {
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows && collapsedRows.length) {
                  var filteredCollapsedRows = collapsedRows.filter(predicate);
                  collapsedRowsMeta.push([row, filteredCollapsedRows]);
                  return !!filteredCollapsedRows.length || predicate(row);
              }
              if (predicate(row)) {
                  collapsedRowsMeta.push([row, []]);
                  return true;
              }
              return false;
          }
          return predicate(row);
      });
      return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };
  };
  var buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {
      var getSimplePredicate = function (filter) {
          var columnName = filter.columnName;
          var customPredicate = getColumnPredicate && getColumnPredicate(columnName);
          var predicate = customPredicate || defaultFilterPredicate;
          return function (row) { return predicate(getCellValue(row, columnName), filter, row); };
      };
      var getOperatorPredicate = function (filterExpression) {
          var build = operators[toLowerCase(filterExpression.operator)];
          return build && build(filterExpression.filters.map(getPredicate));
      };
      var getPredicate = function (filterExpression) { return (getOperatorPredicate(filterExpression)
          || getSimplePredicate(filterExpression)); };
      return getPredicate(initialFilterExpression);
  };
  var filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {
      if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return { rows: rows };
      }
      var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);
      return getRowLevelKey
          ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)
          : { rows: rows.filter(predicate) };
  };
  var filteredCollapsedRowsGetter = function (_a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta && collapsedRowsMeta.get(row); };
  };
  var unwrappedFilteredRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var GROUP_KEY_SEPARATOR = '|';

  var applyColumnGrouping = function (grouping, _a) {
      var columnName = _a.columnName, groupIndex = _a.groupIndex;
      var nextGrouping = grouping;
      var groupingIndex = nextGrouping.findIndex(function (g) { return g.columnName === columnName; });
      var targetIndex = groupIndex;
      if (groupingIndex > -1) {
          nextGrouping = dxCore.slice(grouping);
          nextGrouping.splice(groupingIndex, 1);
      }
      else if (groupIndex === undefined) {
          targetIndex = nextGrouping.length;
      }
      if (targetIndex > -1) {
          nextGrouping = dxCore.slice(nextGrouping);
          nextGrouping.splice(targetIndex, 0, {
              columnName: columnName,
          });
      }
      return nextGrouping;
  };
  var changeColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      var nextGrouping = applyColumnGrouping(grouping, { columnName: columnName, groupIndex: groupIndex });
      var ungroupedColumnIndex = grouping.findIndex(function (group, index) { return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName; });
      if (ungroupedColumnIndex === -1) {
          return {
              grouping: nextGrouping,
          };
      }
      var filteredExpandedGroups = expandedGroups.filter(function (group) { return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex; });
      if (filteredExpandedGroups.length === expandedGroups.length) {
          return {
              grouping: nextGrouping,
          };
      }
      return {
          grouping: nextGrouping,
          expandedGroups: filteredExpandedGroups,
      };
  };
  var toggleExpandedGroups = function (state, _a) {
      var groupKey = _a.groupKey;
      var expandedGroups = dxCore.slice(state.expandedGroups);
      var groupKeyIndex = expandedGroups.indexOf(groupKey);
      if (groupKeyIndex > -1) {
          expandedGroups.splice(groupKeyIndex, 1);
      }
      else {
          expandedGroups.push(groupKey);
      }
      return {
          expandedGroups: expandedGroups,
      };
  };
  var draftColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, draftGrouping = _a.draftGrouping;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      return ({
          draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName: columnName, groupIndex: groupIndex }),
      });
  };
  var cancelColumnGroupingDraft = function () { return ({
      draftGrouping: null,
  }); };

  var adjustSortIndex = function (groupingIndex, grouping, sorting) { return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {
      var columnSortingIndex = sorting.findIndex(function (columnSorting) { return columnSorting.columnName === columnGrouping.columnName; });
      return (columnSortingIndex === -1 ? acc - 1 : acc);
  }, groupingIndex), 0); };

  var groupRowChecker = function (row) { return row[GRID_GROUP_CHECK]; };
  var groupRowLevelKeyGetter = function (row) { return (row ? row[GRID_GROUP_LEVEL_KEY] : undefined); };
  var defaultColumnCriteria = function (value) { return ({
      value: value,
      key: String(value),
  }); };
  var groupedRows = function (rows, grouping, getCellValue, getColumnCriteria, keyPrefix) {
      if (keyPrefix === void 0) { keyPrefix = ''; }
      if (!grouping.length)
          return rows;
      var columnName = grouping[0].columnName;
      var groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))
          || defaultColumnCriteria;
      var groups = new Map();
      rows.forEach(function (row) {
          var rawValue = getCellValue(row, columnName);
          var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;
          var sameKeyItems = groups.get(key);
          if (!sameKeyItems) {
              var groupingValue = value === rawValue ? value : value || key;
              groups.set(key, [groupingValue, key, [row]]);
          }
          else {
              sameKeyItems[2].push(row);
          }
      });
      var groupedBy = grouping[0].columnName;
      var nestedGrouping = grouping.slice(1);
      return __spread(groups.values()).reduce(function (acc, _a) {
          var _b;
          var _c = __read(_a, 3), value = _c[0], key = _c[1], items = _c[2];
          var compoundKey = "" + keyPrefix + key;
          acc.push((_b = {
                  groupedBy: groupedBy,
                  compoundKey: compoundKey,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b));
          acc.push.apply(acc, __spread(groupedRows(items, nestedGrouping, getCellValue, getColumnCriteria, "" + compoundKey + GROUP_KEY_SEPARATOR)));
          return acc;
      }, []);
  };
  var expandedGroupRows = function (rows, grouping, expandedGroups) {
      if (!grouping.length)
          return rows;
      var groupingColumnNames = grouping.map(function (columnGrouping) { return columnGrouping.columnName; });
      var expandedGroupsSet = new Set(expandedGroups);
      var currentGroupExpanded = true;
      var currentGroupLevel = 0;
      return rows.reduce(function (acc, row) {
          var _a;
          if (!row[GRID_GROUP_CHECK]) {
              if (currentGroupExpanded) {
                  acc.push(row);
              }
              else {
                  acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);
              }
              return acc;
          }
          var groupLevel = groupingColumnNames.indexOf(row.groupedBy);
          if (groupLevel > currentGroupLevel && !currentGroupExpanded) {
              return acc;
          }
          currentGroupExpanded = expandedGroupsSet.has(row.compoundKey);
          currentGroupLevel = groupLevel;
          if (currentGroupExpanded) {
              acc.push(row);
          }
          else {
              acc.push(__assign({}, row, (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));
          }
          return acc;
      }, []);
  };
  var groupCollapsedRowsGetter = function (getCollapsedRows) { return function (row) { return (row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))); }; };

  var customGroupedRows = function (currentRows, grouping, getChildGroups, rootRows, keyPrefix) {
      if (rootRows === void 0) { rootRows = currentRows; }
      if (keyPrefix === void 0) { keyPrefix = ''; }
      if (!currentRows || !currentRows.length)
          return [];
      if (!grouping.length)
          return currentRows;
      var groupedBy = grouping[0].columnName;
      var nestedGrouping = grouping.slice(1);
      return getChildGroups(currentRows, grouping[0], rootRows)
          .reduce(function (acc, _a) {
          var _b;
          var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;
          var compoundKey = "" + keyPrefix + key;
          acc.push((_b = {
                  groupedBy: groupedBy,
                  compoundKey: compoundKey,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b));
          acc.push.apply(acc, __spread(customGroupedRows(childRows, nestedGrouping, getChildGroups, rootRows, "" + compoundKey + GROUP_KEY_SEPARATOR)));
          return acc;
      }, []);
  };
  var customGroupingRowIdGetter = function (getRowId, rows) {
      var firstRow = rows.find(function (row) { return !row[GRID_GROUP_CHECK]; });
      if (!firstRow || getRowId(firstRow) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .filter(function (row) { return !row[GRID_GROUP_CHECK]; })
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };

  var groupingPanelItems = function (columns, grouping, draftGrouping) {
      var items = draftGrouping.map(function (_a) {
          var columnName = _a.columnName;
          return ({
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: !grouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }),
          });
      });
      grouping.forEach(function (_a, index) {
          var columnName = _a.columnName;
          if (draftGrouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }))
              return;
          items.splice(index, 0, {
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: true,
          });
      });
      return items;
  };

  var setCurrentPage = function (prevPage, page) { return page; };
  var setPageSize = function (prevPageSize, size) { return size; };

  var clamp = function (value, max) { return (Math.max(Math.min(value, max), 0)); };

  // tslint:disable-next-line:max-line-length
  var PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';
  var paginatedRows = function (rows, pageSize, page) { return (pageSize
      ? rows.slice(pageSize * page, pageSize * (page + 1))
      : rows); };
  var rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {
      if (!pageSize || !getRowLevelKey)
          return rows;
      var result = rows.slice();
      var headerRows = [];
      var currentIndex = 0;
      var _loop_1 = function () {
          var row = result[currentIndex];
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var headerIndex = headerRows.findIndex(function (headerRow) { return getRowLevelKey(headerRow) === levelKey; });
              // tslint:disable-next-line:prefer-conditional-expression
              if (headerIndex === -1) {
                  headerRows = __spread(headerRows, [row]);
              }
              else {
                  headerRows = __spread(headerRows.slice(0, headerIndex), [row]);
              }
              if (headerRows.length >= pageSize) {
                  throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);
              }
          }
          var indexInPage = currentIndex % pageSize;
          if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {
              result = __spread(result.slice(0, currentIndex), [
                  headerRows[indexInPage]
              ], result.slice(currentIndex));
          }
          currentIndex += 1;
      };
      while (result.length > currentIndex) {
          _loop_1();
      }
      return result;
  };
  var rowCount = function (rows) { return rows.length; };
  var pageCount = function (count, pageSize) { return (pageSize ? Math.ceil(count / pageSize) : 1); };
  var currentPage = function (page, totalCount, pageSize, setCurrentPage) {
      var totalPages = pageCount(totalCount, pageSize);
      var adjustedCurrentPage = clamp(page, totalPages - 1);
      if (page !== adjustedCurrentPage) {
          setTimeout(function () { return setCurrentPage(adjustedCurrentPage); });
      }
      return adjustedCurrentPage;
  };

  var firstRowOnPage = function (currentPage, pageSize, totalCount) {
      if (totalCount === 0) {
          return 0;
      }
      return pageSize ? (currentPage * pageSize) + 1 : 1;
  };
  var lastRowOnPage = function (currentPage, pageSize, totalRowCount) {
      var result = totalRowCount;
      if (pageSize) {
          var index = (currentPage + 1) * pageSize;
          result = index > totalRowCount ? totalRowCount : index;
      }
      return result;
  };
  var calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) { return (Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), (totalPageCount - maxButtonCount) + 1), 1)); };

  var toggle = function (source, items, state) {
      var itemsSet = new Set(items);
      var sourceState = state;
      if (sourceState === undefined) {
          var availableSelection = source.filter(function (item) { return itemsSet.has(item); });
          sourceState = availableSelection.length !== itemsSet.size;
      }
      if (sourceState) {
          var sourceSet_1 = new Set(source);
          return __spread(source, items.filter(function (item) { return !sourceSet_1.has(item); }));
      }
      return source.filter(function (item) { return !itemsSet.has(item); });
  };

  var toggleSelection = function (selection, _a) {
      var rowIds = _a.rowIds, state = _a.state;
      return toggle(selection, rowIds, state);
  };

  var rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {
      var dataRows = rows;
      if (isGroupRow) {
          dataRows = dataRows.filter(function (row) { return !isGroupRow(row); });
      }
      return { rows: rows, availableToSelect: dataRows.map(function (row) { return getRowId(row); }) };
  };
  var someSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return availableToSelect.length !== 0 && selectionSet.size !== 0
          && availableToSelect.some(function (elem) { return selectionSet.has(elem); })
          && availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var allSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return selectionSet.size !== 0 && availableToSelect.length !== 0
          && !availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var unwrapSelectedRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var startEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread(prevEditingRowIds, rowIds);
  };
  var stopEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return prevEditingRowIds.filter(function (id) { return !rowIdSet.has(id); });
  };
  var addRow = function (addedRows, _a) {
      var row = (_a === void 0 ? { row: {} } : _a).row;
      return __spread(addedRows, [row]);
  };
  var changeAddedRow = function (addedRows, _a) {
      var rowId = _a.rowId, change = _a.change;
      var result = addedRows.slice();
      result[rowId] = __assign({}, result[rowId], change);
      return result;
  };
  var cancelAddedRows = function (addedRows, _a) {
      var rowIds = _a.rowIds;
      var result = [];
      var indexSet = new Set(rowIds);
      addedRows.forEach(function (row, index) {
          if (!indexSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var changeRow = function (prevRowChanges, _a) {
      var _b;
      var rowId = _a.rowId, change = _a.change;
      var prevChange = prevRowChanges[rowId] || {};
      return __assign({}, prevRowChanges, (_b = {}, _b[rowId] = __assign({}, prevChange, change), _b));
  };
  var cancelChanges = function (prevRowChanges, _a) {
      var rowIds = _a.rowIds;
      var result = __assign({}, prevRowChanges);
      rowIds.forEach(function (rowId) {
          delete result[rowId];
      });
      return result;
  };
  var deleteRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread(deletedRowIds, rowIds);
  };
  var cancelDeletedRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return deletedRowIds.filter(function (rowId) { return !rowIdSet.has(rowId); });
  };

  var changedRowsByIds = function (changes, rowIds) {
      var result = {};
      rowIds.forEach(function (rowId) {
          result[rowId] = changes[rowId];
      });
      return result;
  };
  var addedRowsByIds = function (addedRows, rowIds) {
      var rowIdSet = new Set(rowIds);
      var result = [];
      addedRows.forEach(function (row, index) {
          if (rowIdSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var defaultCreateRowChange = function (row, value, columnName) {
      var _a;
      return (_a = {}, _a[columnName] = value, _a);
  };
  var createRowChangeGetter = function (createRowChange, columnExtensions) {
      if (createRowChange === void 0) { createRowChange = defaultCreateRowChange; }
      if (columnExtensions === void 0) { columnExtensions = []; }
      var map = columnExtensions.reduce(function (acc, columnExtension) {
          if (columnExtension.createRowChange) {
              acc[columnExtension.columnName] = columnExtension.createRowChange;
          }
          return acc;
      }, {});
      return function (row, value, columnName) {
          if (map[columnName]) {
              return map[columnName](row, value, columnName);
          }
          return createRowChange(row, value, columnName);
      };
  };

  var getRowChange = function (rowChanges, rowId) { return rowChanges[rowId] || {}; };

  var TABLE_REORDERING_TYPE = Symbol('reordering');

  var changeColumnOrder = function (order, _a) {
      var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;
      var sourceColumnIndex = order.indexOf(sourceColumnName);
      var targetColumnIndex = order.indexOf(targetColumnName);
      var newOrder = dxCore.slice(order);
      newOrder.splice(sourceColumnIndex, 1);
      newOrder.splice(targetColumnIndex, 0, sourceColumnName);
      return newOrder;
  };

  var TABLE_DATA_TYPE = Symbol('data');
  var TABLE_NODATA_TYPE = Symbol('nodata');
  var TABLE_FLEX_TYPE = Symbol('flex');

  var orderedColumns = function (tableColumns, order) { return mergeSort(tableColumns, function (a, b) {
      if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)
          return 0;
      var aPos = order.indexOf(a.column.name);
      var bPos = order.indexOf(b.column.name);
      return aPos - bPos;
  }); };
  var tableHeaderRowsWithReordering = function (tableHeaderRows) { return __spread(tableHeaderRows, [
      {
          key: TABLE_REORDERING_TYPE.toString(),
          type: TABLE_REORDERING_TYPE,
          height: 0,
      },
  ]); };
  var draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {
      if (sourceColumnIndex === -1
          || targetColumnIndex === -1
          || sourceColumnIndex === targetColumnIndex) {
          return order;
      }
      var result = dxCore.slice(order);
      var sourceColumn = order[sourceColumnIndex];
      result.splice(sourceColumnIndex, 1);
      result.splice(targetColumnIndex, 0, sourceColumn);
      return result;
  };

  var UNSET_COLUMN_WIDTH_ERROR = [
      'The "$1" column\'s width is not specified.',
      'The TableColumnResizing plugin requires that all columns have the specified width.',
  ].join('\n');
  var specifyWidths = function (tableColumns, widths, onAbsence) {
      if (!widths.length)
          return tableColumns;
      return tableColumns
          .reduce(function (acc, tableColumn) {
          if (tableColumn.type === TABLE_DATA_TYPE) {
              var columnName_1 = tableColumn.column.name;
              var column = widths.find(function (el) { return el.columnName === columnName_1; });
              var width = column && column.width;
              if (width === undefined) {
                  onAbsence(columnName_1);
                  acc.push(tableColumn);
              }
              else {
                  acc.push(__assign({}, tableColumn, { width: width }));
              }
          }
          else {
              acc.push(tableColumn);
          }
          return acc;
      }, []);
  };
  var tableColumnsWithWidths = function (tableColumns, columnWidths) { return specifyWidths(tableColumns, columnWidths, function (columnName) {
      throw new Error(UNSET_COLUMN_WIDTH_ERROR.replace('$1', columnName));
  }); };
  var tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths) { return specifyWidths(tableColumns, draftColumnWidths, function () { }); };

  var changeTableColumnWidth = function (state, _a) {
      var columnName = _a.columnName, shift = _a.shift, minColumnWidth = _a.minColumnWidth;
      var columnWidths = state.columnWidths;
      var nextColumnWidth = dxCore.slice(columnWidths);
      var index = nextColumnWidth.findIndex(function (elem) { return elem.columnName === columnName; });
      var updatedColumn = nextColumnWidth[index];
      var size = Math.max(minColumnWidth, updatedColumn.width + shift);
      nextColumnWidth.splice(index, 1, { columnName: columnName, width: size });
      return {
          columnWidths: nextColumnWidth,
      };
  };
  var draftTableColumnWidth = function (state, _a) {
      var columnName = _a.columnName, shift = _a.shift, minColumnWidth = _a.minColumnWidth;
      var columnWidths = state.columnWidths;
      var updatedColumn = columnWidths.find(function (elem) { return elem.columnName === columnName; });
      var size = Math.max(minColumnWidth, updatedColumn.width + shift);
      return {
          draftColumnWidths: [{ columnName: updatedColumn.columnName, width: size }],
      };
  };
  var cancelTableColumnWidthDraft = function () { return ({
      draftColumnWidths: [],
  }); };

  var TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');

  var TABLE_ADDED_TYPE = Symbol('added');
  var TABLE_EDIT_TYPE = Symbol('edit');

  var TABLE_HEADING_TYPE = Symbol('heading');

  var isHeadingEditCommandsTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };
  var isEditCommandsTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE
      || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };

  var tableColumnsWithEditing = function (tableColumns, width) { return __spread([
      { width: width, key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE }
  ], tableColumns); };

  var isEditTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)
      && tableColumn.type === TABLE_DATA_TYPE; };
  var isAddedTableRow = function (tableRow) { return tableRow.type === TABLE_ADDED_TYPE; };
  var isEditTableRow = function (tableRow) { return tableRow.type === TABLE_EDIT_TYPE; };

  var tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {
      var rowIds = new Set(editingRowIds);
      var editedTableRows = tableRows
          .map(function (tableRow) { return (tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId)
          ? __assign({}, tableRow, { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow); });
      var addedTableRows = addedRows
          .map(function (row, rowIndex) { return ({
          row: row,
          key: TABLE_ADDED_TYPE.toString() + "_" + rowIndex,
          type: TABLE_ADDED_TYPE,
          rowId: rowIndex,
          height: rowHeight,
      }); });
      return __spread(dxCore.slice(addedTableRows).reverse(), editedTableRows);
  };

  var TABLE_FILTER_TYPE = Symbol('filter');
  var DEFAULT_FILTER_OPERATIONS = [
      'contains',
      'notContains',
      'startsWith',
      'endsWith',
      'equal',
      'notEqual',
  ];

  var isFilterTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isFilterTableRow = function (tableRow) { return tableRow.type === TABLE_FILTER_TYPE; };
  var getColumnFilterOperations = function (getAvailableFilterOperations, columnName) { return (getAvailableFilterOperations && getAvailableFilterOperations(columnName))
      || DEFAULT_FILTER_OPERATIONS; };
  var isFilterValueEmpty = function (value) { return value === undefined || !String(value).length; };
  var getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {
      if (columnFilter && columnFilter.operation) {
          return columnFilter.operation;
      }
      if (filterOperations[columnName]) {
          return filterOperations[columnName];
      }
      return columnFilterOperations[0];
  };

  var tableHeaderRowsWithFilter = function (headerRows, rowHeight) { return __spread(headerRows, [
      { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }
  ]); };

  var TABLE_GROUP_TYPE = Symbol('group');

  var isGroupTableCell = function (tableRow, tableColumn) { return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
      && tableColumn.column
      && tableColumn.column.name === tableRow.row.groupedBy); };
  var isGroupIndentTableCell = function (tableRow, tableColumn, grouping) {
      if (tableRow.type !== TABLE_GROUP_TYPE || tableColumn.type !== TABLE_GROUP_TYPE)
          return false;
      if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)
          return false;
      var rowGroupIndex = grouping.findIndex(function (columnGrouping) { return columnGrouping.columnName === tableRow.row.groupedBy; });
      var columnGroupIndex = grouping.findIndex(function (columnGrouping) { return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name; });
      return columnGroupIndex < rowGroupIndex;
  };
  var isGroupTableRow = function (tableRow) { return tableRow.type === TABLE_GROUP_TYPE; };

  var tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) { return tableColumns
      .reduce(function (acc, tableColumn) {
      if (tableColumn.type !== TABLE_DATA_TYPE) {
          acc.push(tableColumn);
          return acc;
      }
      var columnName = tableColumn.column && tableColumn.column.name || '';
      var columnGroupingExists = grouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      var columnDraftGroupingExists = draftGrouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      if ((!columnGroupingExists && !columnDraftGroupingExists)
          || showColumnWhenGrouped(columnName)) {
          acc.push(tableColumn);
      }
      else if ((!columnGroupingExists && columnDraftGroupingExists)
          || (columnGroupingExists && !columnDraftGroupingExists)) {
          acc.push(__assign({}, tableColumn, { draft: true }));
      }
      return acc;
      // tslint:disable-next-line: prefer-array-literal
  }, []); };
  var tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) { return __spread(grouping.map(function (columnGrouping) {
      var groupedColumn = columns.find(function (column) { return column.name === columnGrouping.columnName; });
      return {
          key: TABLE_GROUP_TYPE.toString() + "_" + groupedColumn.name,
          type: TABLE_GROUP_TYPE,
          column: groupedColumn,
          width: indentColumnWidth,
      };
  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped)); };
  var tableRowsWithGrouping = function (tableRows, isGroupRow) { return tableRows.map(function (tableRow) {
      if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {
          return tableRow;
      }
      return __assign({}, tableRow, { key: TABLE_GROUP_TYPE.toString() + "_" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });
  }); };
  var tableGroupCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
          && tableRow.row.groupedBy === tableColumn.column.name) {
          return tableColumns.length - tableColumns.indexOf(tableColumn);
      }
      return getTableCellColSpan(params);
  }; };

  var isHeadingTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeadingTableRow = function (tableRow) { return (tableRow.type === TABLE_HEADING_TYPE); };
  var findChainByColumnIndex = function (chains, columnIndex) { return (chains.find(function (chain) { return (chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length); })); };
  var splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) { return (tableColumnChains.map(function (row, rowIndex) { return row
      .reduce(function (acc, chain) {
      var currentChain = null;
      chain.columns.forEach(function (col) {
          var column = tableColumns.find(function (c) { return c.key === col.key; });
          var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);
          if (isNewGroup) {
              var start = currentChain
                  ? (currentChain.start + currentChain.columns.length)
                  : chain.start;
              acc.push(__assign({}, chain, extendChainProps(column), { start: start, columns: [] }));
              currentChain = acc[acc.length - 1];
          }
          currentChain.columns.push(column);
      });
      return acc;
  }, []); })); };
  var generateSimpleChains = function (rows, columns) { return (rows.map(function () { return ([{
          columns: columns,
          start: 0,
      }]); })); };

  var tableRowsWithHeading = function (headerRows) { return __spread([
      { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }
  ], headerRows); };

  var TABLE_BAND_TYPE = Symbol('band');
  var BAND_GROUP_CELL = 'bandGroupCell';
  var BAND_HEADER_CELL = 'bandHeaderCell';
  var BAND_EMPTY_CELL = 'bandEmptyCell';
  var BAND_DUPLICATE_RENDER = 'bandDuplicateRender';

  var isBandedTableRow = function (tableRow) { return (tableRow.type === TABLE_BAND_TYPE); };
  var isBandedOrHeaderRow = function (tableRow) { return isBandedTableRow(tableRow)
      || tableRow.type === TABLE_HEADING_TYPE; };
  var isNoDataColumn = function (columnType) { return columnType !== TABLE_DATA_TYPE; };
  var getColumnMeta = function (columnName, bands, tableRowLevel, level, title, result) {
      if (level === void 0) { level = 0; }
      if (title === void 0) { title = null; }
      if (result === void 0) { result = null; }
      return bands.reduce(function (acc, column) {
          if (column.columnName === columnName) {
              return __assign({}, acc, { title: title, level: level });
          }
          if (column.children !== undefined) {
              return getColumnMeta(columnName, column.children, tableRowLevel, level + 1, level > tableRowLevel ? title : column.title, acc);
          }
          return acc;
      }, result || { level: level, title: title });
  };
  var getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains) {
      var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;
      if (rowSpan)
          return { type: BAND_DUPLICATE_RENDER, payload: null };
      var maxLevel = tableHeaderRows.filter(function (column) { return column.type === TABLE_BAND_TYPE; }).length + 1;
      var level = tableRow.level;
      var currentRowLevel = level === undefined
          ? maxLevel - 1 : level;
      var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE
          ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel)
          : { level: 0, title: '' };
      if (currentColumnMeta.level < currentRowLevel)
          return { type: BAND_EMPTY_CELL, payload: null };
      var currentColumnIndex = tableColumns
          .findIndex(function (column) { return column.key === currentTableColumn.key; });
      var previousTableColumn = tableColumns[currentColumnIndex - 1];
      var beforeBorder = false;
      if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE
          && isNoDataColumn(previousTableColumn.type)) {
          beforeBorder = true;
      }
      if (currentColumnMeta.level === currentRowLevel) {
          return {
              type: BAND_HEADER_CELL,
              payload: __assign({ tableRow: tableHeaderRows.find(function (row) { return row.type === TABLE_HEADING_TYPE; }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder: beforeBorder }),
          };
      }
      var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);
      if (currentColumnChain.start < currentColumnIndex) {
          return { type: null, payload: null };
      }
      return {
          type: BAND_GROUP_CELL,
          payload: __assign({ colSpan: currentColumnChain.columns.length, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder: beforeBorder }),
      };
  };

  var tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {
      var tableDataColumns = tableColumns.filter(function (column) { return column.type === TABLE_DATA_TYPE; });
      var getMaxNestedLevel = function (bands, level, result) {
          if (level === void 0) { level = 0; }
          if (result === void 0) { result = null; }
          return (bands.reduce(function (acc, column) {
              if (column.children !== undefined) {
                  return getMaxNestedLevel(column.children, level + 1, acc);
              }
              var isDataColumn = tableDataColumns.findIndex(function (dataColumn) { return !!dataColumn.column && dataColumn.column.name === column.columnName; }) > -1;
              if (level > acc.level && isDataColumn) {
                  return __assign({}, acc, { level: level });
              }
              return acc;
          }, result || { level: 0 }));
      };
      var tableBandHeaders = Array.from({
          length: getMaxNestedLevel(columnBands, 0).level,
      })
          .map(function (row, index) { return ({
          key: TABLE_BAND_TYPE.toString() + "_" + index,
          type: TABLE_BAND_TYPE,
          level: index,
      }); });
      return __spread(tableBandHeaders, tableHeaderRows);
  };
  var tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {
      var chains = generateSimpleChains(tableHeaderRows, tableColumns);
      var maxBandRowIndex = tableHeaderRows
          .filter(function (row) { return row.type === TABLE_BAND_TYPE; })
          .length;
      var rawBandChains = chains.slice(0, maxBandRowIndex);
      var currentBand = null;
      var shouldSplitChain = function (chain, column, rowIndex) {
          if (rowIndex > maxBandRowIndex)
              return false;
          var columnName = column.column && column.column.name || '';
          currentBand = getColumnMeta(columnName, bands, rowIndex);
          return !chain
              || chain.bandTitle !== currentBand.title;
      };
      var extendChainProps = function () { return ({
          bandTitle: (currentBand || {}).title,
      }); };
      var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);
      return __spread(bandChains, chains.slice(maxBandRowIndex));
  };

  var toggleDetailRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var TABLE_DETAIL_TYPE = Symbol('detail');

  var isDetailRowExpanded = function (expandedDetailRowIds, rowId) { return expandedDetailRowIds.indexOf(rowId) > -1; };
  var isDetailToggleTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isDetailTableRow = function (tableRow) { return tableRow.type === TABLE_DETAIL_TYPE; };
  var isDetailTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };

  var tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {
      var result = tableRows;
      expandedDetailRowIds
          .forEach(function (expandedRowId) {
          var rowIndex = result.findIndex(function (tableRow) { return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId; });
          if (rowIndex === -1)
              return;
          var insertIndex = rowIndex + 1;
          var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;
          result = __spread(result.slice(0, insertIndex), [
              {
                  rowId: rowId,
                  row: row,
                  key: TABLE_DETAIL_TYPE.toString() + "_" + rowId,
                  type: TABLE_DETAIL_TYPE,
                  height: rowHeight,
              }
          ], result.slice(insertIndex));
      });
      return result;
  };
  var tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) { return __spread([
      { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }
  ], tableColumns); };
  var tableDetailCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return getTableCellColSpan(params);
  }; };

  var TABLE_SELECT_TYPE = Symbol('select');

  var isSelectTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isSelectAllTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE; };

  var tableColumnsWithSelection = function (tableColumns, selectionColumnWidth) { return __spread([
      { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }
  ], tableColumns); };

  var TABLE_STUB_TYPE = Symbol('stub');
  var getVisibleBoundaryWithFixed = function (visibleBoundary, items) { return items.reduce(function (acc, item, index) {
      if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {
          acc.push([index, index]);
      }
      return acc;
  }, [visibleBoundary]); };
  var getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {
      if (offset === void 0) { offset = 0; }
      if (itemSize === void 0) { itemSize = 0; }
      var start = null;
      var end = null;
      var index = 0;
      var beforePosition = offset * itemSize;
      var noVisibleRowsLoaded = itemSize > 0 &&
          beforePosition + items.length * itemSize < viewportStart ||
          viewportStart < beforePosition;
      if (noVisibleRowsLoaded) {
          beforePosition = viewportStart;
          index = items.length;
          start = Math.round(viewportStart / itemSize) - offset;
          end = start;
      }
      var viewportEnd = viewportStart + viewportSize;
      while (end === null && index < items.length) {
          var item = items[index];
          var afterPosition = beforePosition + getItemSize(item);
          var isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)
              || (afterPosition > viewportStart && afterPosition <= viewportEnd)
              || (beforePosition < viewportStart && afterPosition > viewportEnd);
          if (isVisible && start === null) {
              start = index;
          }
          if (!isVisible && start !== null) {
              end = index - 1;
              break;
          }
          index += 1;
          beforePosition = afterPosition;
      }
      if (start !== null && end === null) {
          end = index - 1;
      }
      start = start === null ? 0 : start;
      end = end === null ? 0 : end;
      return [start + offset, end + offset];
  };
  var getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {
      var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];
      start = Math.max(0, start - overscan);
      end = Math.min(itemsCount - 1, end + overscan);
      return [start, end];
  };
  var getColumnBoundaries = function (columns, left, width, getColumnWidth) { return (getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns)); };
  var getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight) {
      var boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);
      var start = boundaries[0];
      var end = boundaries[1];
      return {
          start: start,
          end: end,
      };
  };
  var getColumnsRenderBoundary = function (columnCount, visibleBoundary) { return getRenderBoundary(columnCount, visibleBoundary, 1); };
  var getRowsRenderBoundary = function (rowsCount, visibleBoundary) { return getRenderBoundary(rowsCount, visibleBoundary, 3); };
  var getSpanBoundary = function (items, visibleBoundaries, getItemSpan) { return visibleBoundaries
      .map(function (visibleBoundary) {
      var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];
      for (var index = 0; index <= visibleBoundary[1]; index += 1) {
          var span = getItemSpan(items[index]);
          if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {
              start = index;
          }
          if (index + (span - 1) > visibleBoundary[1]) {
              end = index + (span - 1);
          }
      }
      return [start, end];
  }); };
  var collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {
      var breakpoints = new Set([0, itemsCount]);
      spanBoundaries.forEach(function (rowBoundaries) { return rowBoundaries
          .forEach(function (boundary) {
          breakpoints.add(boundary[0]);
          if (boundary[1] - 1 < itemsCount) {
              // next interval starts after span end point
              breakpoints.add(boundary[1] + 1);
          }
      }); });
      visibleBoundaries
          .filter(function (boundary) { return boundary.every(function (bound) { return 0 <= bound && bound < itemsCount; }); })
          .forEach(function (boundary) {
          for (var point = boundary[0]; point <= boundary[1]; point += 1) {
              breakpoints.add(point);
          }
          if (boundary[1] + 1 < itemsCount) {
              // close last visible point
              breakpoints.add(boundary[1] + 1);
          }
      });
      var bp = __spread(breakpoints).sort(function (a, b) { return a - b; });
      var bounds = [];
      for (var i = 0; i < bp.length - 1; i += 1) {
          bounds.push([
              bp[i],
              bp[i + 1] - 1,
          ]);
      }
      return bounds;
  };
  var getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {
      var size = 0;
      for (var i = startIndex; i <= endIndex; i += 1) {
          size += getColumnSize(columns[i], 0) || 0;
      }
      return size;
  };
  var getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {
      var collapsedColumns = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) { return (acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])); }, false);
          if (isVisible) {
              var column = columns[boundary[0]];
              collapsedColumns.push(__assign({}, column, { width: getColumnWidth(column) }));
          }
          else {
              collapsedColumns.push({
                  key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                  type: TABLE_STUB_TYPE,
                  width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),
              });
          }
      });
      return collapsedColumns;
  };
  var getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {
      var collapsedRows = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
          if (isVisible) {
              var row = rows[boundary[0] - offset];
              collapsedRows.push({
                  row: row,
                  cells: getCells(row),
              });
          }
          else {
              var row = {};
              collapsedRows.push({
                  row: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                      height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),
                  },
                  cells: getCells(row),
              });
          }
      });
      return collapsedRows;
  };
  var getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {
      var collapsedCells = [];
      var index = 0;
      var _loop_1 = function () {
          var boundary = boundaries[index];
          var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) { return (acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])); }, false);
          if (isSpan) {
              var column = columns[boundary[0]];
              var realColSpan = getColSpan(column);
              var realColSpanEnd_1 = (realColSpan + boundary[0]) - 1;
              var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) { return colSpanBoundary[0]
                  <= realColSpanEnd_1 && realColSpanEnd_1
                  <= colSpanBoundary[1]; });
              collapsedCells.push({
                  column: column,
                  colSpan: (colSpanEnd - index) + 1,
              });
              index += 1;
          }
          else {
              collapsedCells.push({
                  column: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                  },
                  colSpan: 1,
              });
              index += 1;
          }
      };
      while (index < boundaries.length) {
          _loop_1();
      }
      return collapsedCells;
  };
  var getCollapsedGrid = function (_a) {
      var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, _b = _a.getColumnWidth, getColumnWidth = _b === void 0 ? function (column) { return column.width; } : _b, _c = _a.getRowHeight, getRowHeight = _c === void 0 ? function (row) { return row.height; } : _c, _d = _a.getColSpan, getColSpan = _d === void 0 ? function () { return 1; } : _d, totalRowCount = _a.totalRowCount, offset = _a.offset;
      if (!columns.length) {
          return {
              columns: [],
              rows: [],
          };
      }
      var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];
      var rowSpanBoundaries = rows
          .slice(boundaries[0], boundaries[1])
          .map(function (row) { return getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }); });
      var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries, 0);
      var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], [], offset);
      return {
          columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),
          rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) { return getCollapsedCells(columns, getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }), columnBoundaries, function (column) { return getColSpan(row, column); }); }, offset),
      };
  };
  var getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {
      var colsHavingWidth = tableColumns.filter(function (col) { return col.width !== undefined; });
      var columnsWidth = colsHavingWidth.reduce(function (acc, col) { return (acc + col.width); }, 0);
      var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);
      var autoColWidth = Math.max(autoWidth, minColumnWidth);
      return function (column) { return (column.type === TABLE_FLEX_TYPE
          ? null
          : column.width || autoColWidth); };
  };
  var getCollapsedGrids = function (_a) {
      var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewportLeft = _a.viewportLeft, containerWidth = _a.containerWidth, visibleRowBoundaries = _a.visibleRowBoundaries, getColumnWidth = _a.getColumnWidth, getRowHeight = _a.getRowHeight;
      var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
      var columnBoundaries = getColumnBoundaries(columns, viewportLeft, containerWidth, getColumnWidth);
      var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {
          if (rowCount === void 0) { rowCount = rows.length; }
          if (offset === void 0) { offset = 0; }
          return getCollapsedGrid({
              rows: rows,
              columns: columns,
              rowsVisibleBoundary: rowsVisibleBoundary,
              columnsVisibleBoundary: columnBoundaries,
              getColumnWidth: getColumnWidth,
              getRowHeight: getRowHeight,
              getColSpan: getColSpan,
              totalRowCount: rowCount,
              offset: offset,
          });
      };
      var headerGrid = getCollapsedGridBlock(headerRows, getRenderRowBounds(visibleRowBoundaries.header, headerRows.length));
      var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(visibleRowBoundaries.body, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);
      var footerGrid = getCollapsedGridBlock(footerRows, getRenderRowBounds(visibleRowBoundaries.footer, footerRows.length));
      return {
          headerGrid: headerGrid,
          bodyGrid: bodyGrid,
          footerGrid: footerGrid,
      };
  };
  var getRenderRowBounds = function (visibleBounds, rowCount) { return getRowsRenderBoundary(rowCount, [visibleBounds.start, visibleBounds.end]); };
  var adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {
      var renderRowBoundaries = getRenderRowBounds(visibleBounds, loadedRowsStart + rowCount);
      var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart, end: loadedRowsStart + rowCount });
      return [adjustedInterval.start, adjustedInterval.end];
  };

  var isDataTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeaderStubTableCell = function (tableRow, headerRows) { return headerRows.indexOf(tableRow) > -1; };
  var isDataTableRow = function (tableRow) { return tableRow.type === TABLE_DATA_TYPE; };
  var isNoDataTableRow = function (tableRow) { return tableRow.type === TABLE_NODATA_TYPE; };
  var isNoDataTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };
  var isStubTableCell = function (tableRow) { return (tableRow.type === TABLE_STUB_TYPE); };

  var getColumnExtension = function (columnExtensions, columnName) {
      if (!columnExtensions) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      var columnExtension = columnExtensions.find(function (extension) { return extension.columnName === columnName; });
      if (!columnExtension) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      return columnExtension;
  };
  var getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) { return function (columnName) {
      if (columnExtensions) {
          var columnExtension = getColumnExtension(columnExtensions, columnName);
          var extensionValue = columnExtension[extensionName];
          return extensionValue !== undefined ? extensionValue : defaultValue;
      }
      return defaultValue;
  }; };

  var tableColumnsWithDataRows = function (columns, columnExtensions) { return columns.map(function (column) {
      var name = column.name;
      var columnExtension = getColumnExtension(columnExtensions, name);
      return {
          column: column,
          key: TABLE_DATA_TYPE.toString() + "_" + name,
          type: TABLE_DATA_TYPE,
          width: columnExtension.width,
          align: columnExtension.align,
          wordWrapEnabled: columnExtension.wordWrapEnabled,
      };
  }); };
  var tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) { return (!rows.length && !isRemoteRowsLoading
      ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]
      : rows.map(function (row, dataIndex) {
          var rowId = getRowId(row);
          return {
              row: row,
              // dataIndex,
              rowId: rowId,
              type: TABLE_DATA_TYPE,
              key: TABLE_DATA_TYPE.toString() + "_" + rowId,
          };
      })); };
  var tableCellColSpanGetter = function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return 1;
  };

  var visibleTableColumns = function (tableColumns, hiddenColumnNames) { return tableColumns.filter(function (tableColumn) { return tableColumn.type !== TABLE_DATA_TYPE
      || hiddenColumnNames.indexOf(tableColumn.column.name) === -1; }); };

  var tableDataColumnsExist = function (tableColumns) { return tableColumns.some(function (column) { return column.type === TABLE_DATA_TYPE; }); };

  var columnChooserItems = function (columns, hiddenColumnNames) { return columns.map(function (column) { return ({
      column: column,
      hidden: hiddenColumnNames.indexOf(column.name) !== -1,
  }); }); };

  var toggleColumn = function (hiddenColumnNames, columnName) { return (hiddenColumnNames.indexOf(columnName) === -1
      ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) { return hiddenColumn !== columnName; })); };

  var toggleRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var GRID_TREE_NODE_TYPE = Symbol('treeNode');

  var customTreeRows = function (currentRow, getChildRows, rootRows, level) {
      if (level === void 0) { level = 0; }
      var childRows = getChildRows(currentRow, rootRows);
      if (!childRows)
          return { rows: [], treeMeta: [], empty: true };
      return childRows
          .reduce(function (acc, row) {
          var _a, _b;
          var nestedResult = customTreeRows(row, getChildRows, rootRows, level + 1);
          (_a = acc.rows).push.apply(_a, __spread([row], nestedResult.rows));
          (_b = acc.treeMeta).push.apply(_b, __spread([[row, { level: level, leaf: !!nestedResult.empty }]], nestedResult.treeMeta));
          return acc;
      }, { rows: [], treeMeta: [] });
  };
  var customTreeRowsWithMeta = function (rows, getChildRows) {
      var result = customTreeRows(null, getChildRows, rows);
      return {
          rows: result.rows,
          treeMeta: new Map(result.treeMeta),
      };
  };
  var customTreeRowIdGetter = function (getRowId, _a) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var firstNestedRowIndex = rows.findIndex(function (row) { return treeMeta.get(row).level > 0; });
      if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };
  var customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          if (rowMeta !== undefined) {
              return GRID_TREE_NODE_TYPE.toString() + "_" + rowMeta.level;
          }
          return getRowLevelKey && getRowLevelKey();
      };
  };
  var expandedTreeRows = function (_a, getRowId, expandedRowIds) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var expandedRowIdsSet = new Set(expandedRowIds);
      var currentExpanded = true;
      var currentLevel = 0;
      var collapsedRowsMeta = new Map();
      var resultRows = [];
      rows.forEach(function (row) {
          var rowMeta = treeMeta.get(row);
          var level = rowMeta && rowMeta.level;
          if (level === undefined && currentExpanded) {
              resultRows.push(row);
          }
          else if (!currentExpanded && (level === undefined || level > currentLevel)) {
              var lastRow = resultRows[resultRows.length - 1];
              var collapsedItems = collapsedRowsMeta.get(lastRow);
              if (!collapsedItems) {
                  collapsedItems = [];
                  collapsedRowsMeta.set(lastRow, collapsedItems);
              }
              collapsedItems.push(row);
          }
          else {
              currentExpanded = expandedRowIdsSet.has(getRowId(row));
              currentLevel = level;
              resultRows.push(row);
          }
      });
      return {
          treeMeta: treeMeta,
          collapsedRowsMeta: collapsedRowsMeta,
          rows: resultRows,
      };
  };
  var collapsedTreeRowsGetter = function (getCollapsedRows, _a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row)); };
  };
  var isTreeRowLeafGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return rowMeta && rowMeta.leaf;
      };
  };
  var getTreeRowLevelGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return (rowMeta && rowMeta.level);
      };
  };
  var unwrappedCustomTreeRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var isTreeTableCell = function (tableRow, tableColumn, forColumnName) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE
      && tableColumn.column.name === forColumnName; };

  var changeSearchValue = function (prevSearchValue, searchValue) { return searchValue; };

  var searchFilterExpression = function (searchValue, columns, filterExpression) {
      var filters = columns.map(function (_a) {
          var name = _a.name;
          return ({ columnName: name, value: searchValue });
      });
      var selfFilterExpression = { filters: filters, operator: 'or' };
      if (!filterExpression) {
          return selfFilterExpression;
      }
      return {
          operator: 'and',
          filters: [filterExpression, selfFilterExpression],
      };
  };

  var getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) { return function (columnName) { return (columnNames.indexOf(columnName) > -1 && availableFilterOperations)
      // tslint:disable-next-line: max-line-length
      || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))
      || undefined; }; };

  var FIXED_COLUMN_LEFT_SIDE = 'left';
  var FIXED_COLUMN_RIGHT_SIDE = 'right';
  var TABLE_FIXED_TYPE = Symbol('fixed');

  var getFixedColumnKeys = function (tableColumns, fixedNames) { return tableColumns
      .filter(function (tableColumn) { return ((tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1)
      || fixedNames.indexOf(tableColumn.type) !== -1); })
      .map(function (_a) {
      var key = _a.key;
      return key;
  }); };
  var isFixedTableRow = function (tableRow) { return tableRow.type === TABLE_FIXED_TYPE; };
  var calculatePosition = function (array, index, tableColumnDimensions) { return (index === 0
      ? 0
      : array
          .slice(0, index)
          .reduce(function (acc, target) { return acc + tableColumnDimensions[target] || 0; }, 0)); };
  var calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {
      var tableColumn = _a.tableColumn;
      var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;
      var side = tableColumn.fixed;
      var targetArray = side === FIXED_COLUMN_LEFT_SIDE
          ? getFixedColumnKeys(tableColumns, leftColumns)
          : dxCore.slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();
      var index = tableColumns.findIndex(function (_a) {
          var key = _a.key;
          return key === tableColumn.key;
      });
      var fixedIndex = targetArray.indexOf(tableColumn.key);
      var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);
      var showLeftDivider = columnChain.start === index && index !== 0;
      var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index
          && index < tableColumns.length - 1;
      var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);
      return {
          showRightDivider: showRightDivider,
          showLeftDivider: showLeftDivider,
          position: position,
          side: side,
      };
  };

  var tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) { return tableColumns
      .map(function (tableColumn) {
      var fixed;
      if ((tableColumn.type === TABLE_DATA_TYPE
          && leftColumns.indexOf(tableColumn.column.name) !== -1)
          || leftColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_LEFT_SIDE;
      }
      if ((tableColumn.type === TABLE_DATA_TYPE
          && rightColumns.indexOf(tableColumn.column.name) !== -1)
          || rightColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_RIGHT_SIDE;
      }
      return fixed ? __assign({}, tableColumn, { fixed: fixed }) : tableColumn;
  }); };
  var tableHeaderRowsWithFixed = function (tableHeaderRows) { return __spread(tableHeaderRows, [
      { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },
  ]); };
  var tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {
      var chains = tableHeaderColumnChains
          || generateSimpleChains(tableHeaderRows, tableColumns);
      var shouldSplitChain = function (currentGroup, column) { return (!currentGroup || currentGroup.fixed !== column.fixed); };
      var extendChainProps = function (column) { return ({
          fixed: column.fixed,
      }); };
      return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);
  };

  var defaultSummaryCalculators = {
      count: function (rows) { return rows.length; },
      sum: function (rows, getValue) { return rows.reduce(function (acc, row) { return acc + getValue(row); }, 0); },
      max: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.max(acc, getValue(row)); }, -Infinity)
          : null); },
      min: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.min(acc, getValue(row)); }, Infinity)
          : null); },
      avg: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return acc + getValue(row); }, 0) / rows.length
          : null); },
  };
  var defaultSummaryCalculator = function (type, rows, getValue) {
      var summaryCalculator = defaultSummaryCalculators[type];
      if (!summaryCalculator) {
          throw new Error("The summary type '" + type + "' is not defined");
      }
      return summaryCalculator(rows, getValue);
  };
  var rowsSummary = function (rows, summaryItems, getCellValue, calculator) { return summaryItems
      .reduce(function (acc, _a) {
      var type = _a.type, columnName = _a.columnName;
      var getValue = function (row) { return getCellValue(row, columnName); };
      acc.push(calculator(type, rows, getValue));
      return acc;
  }, []); };
  var totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var plainRows = rows.reduce(function (acc, row) {
          if (getRowLevelKey && getRowLevelKey(row)) {
              if (!isGroupRow || !isGroupRow(row)) {
                  acc.push(row);
              }
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows) {
                  acc.push.apply(acc, __spread(collapsedRows));
              }
              return acc;
          }
          acc.push(row);
          return acc;
      }, []);
      return rowsSummary(plainRows, summaryItems, getCellValue, calculator);
  };
  var groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var summaries = {};
      rows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          if (!levelKey) {
              levels.forEach(function (level) {
                  level.rows.push(row);
              });
          }
          var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
          if (levelIndex > -1) {
              levels.slice(levelIndex).forEach(function (level) {
                  summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
              });
              levels = levels.slice(0, levelIndex);
          }
          if (isGroupRow(row)) {
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
          }
      }, {});
      levels.forEach(function (level) {
          summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
      });
      return summaries;
  };
  var treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var summaries = {};
      rows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          if (!levelKey) {
              levels[levels.length - 1].rows.push(row);
              return;
          }
          var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
          if (levelIndex > -1) {
              levels.slice(levelIndex).forEach(function (level) {
                  if (level.rows.length) {
                      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
                  }
              });
              levels = levels.slice(0, levelIndex);
          }
          if (!isGroupRow || !isGroupRow(row)) {
              if (levels.length) {
                  levels[levels.length - 1].rows.push(row);
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
          }
      }, {});
      levels.forEach(function (level) {
          if (level.rows.length) {
              summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
          }
      });
      return summaries;
  };

  var TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');
  var TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');
  var TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');

  var tableRowsWithTotalSummaries = function (footerRows) { return __spread([
      { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }
  ], footerRows); };
  var tableRowsWithSummaries = function (tableRows, getRowLevelKey, isGroupRow, getRowId) {
      if (!getRowLevelKey)
          return tableRows;
      var result = [];
      var closeLevel = function (level) {
          if (!level.opened)
              return;
          if (isGroupRow && isGroupRow(level.row)) {
              var compoundKey = level.row.compoundKey;
              result.push({
                  key: TABLE_GROUP_SUMMARY_TYPE.toString() + "_" + compoundKey,
                  type: TABLE_GROUP_SUMMARY_TYPE,
                  row: level.row,
              });
          }
          else {
              var rowId = getRowId(level.row);
              result.push({
                  key: TABLE_TREE_SUMMARY_TYPE.toString() + "_" + rowId,
                  type: TABLE_TREE_SUMMARY_TYPE,
                  row: level.row,
              });
          }
      };
      var levels = [];
      tableRows.forEach(function (tableRow) {
          var row = tableRow.row;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
              if (levelIndex > -1) {
                  levels.slice(levelIndex).reverse().forEach(closeLevel);
                  levels = levels.slice(0, levelIndex);
              }
              if (!isGroupRow || !isGroupRow(row)) {
                  levels = levels.map(function (level) { return (__assign({}, level, { opened: true })); });
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  opened: false,
              });
          }
          else {
              levels = levels.map(function (level) { return (__assign({}, level, { opened: true })); });
          }
          result.push(tableRow);
      });
      levels.slice().reverse().forEach(closeLevel);
      return result;
  };

  var isTotalSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isGroupSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTreeSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTotalSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TOTAL_SUMMARY_TYPE); };
  var isGroupSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_GROUP_SUMMARY_TYPE); };
  var isTreeSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TREE_SUMMARY_TYPE); };
  var getColumnSummaries = function (summaryItems, columnName, summaryValues) { return summaryItems
      .map(function (item, index) { return [item, index]; })
      .filter(function (_a) {
      var _b = __read(_a, 1), item = _b[0];
      return item.columnName === columnName;
  })
      .map(function (_a) {
      var _b = __read(_a, 2), item = _b[0], index = _b[1];
      return ({
          type: item.type,
          value: summaryValues[index],
      });
  }); };

  var getTargetColumnGeometries = function (columnGeometries, sourceIndex) {
      var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;
      var getWidthDifference = function (index) { return columnGeometries[index].right
          - columnGeometries[index].left
          - sourceWidth; };
      return columnGeometries
          .map(function (_a, targetIndex) {
          var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
          var leftBorder = left;
          if (targetIndex > 0 && targetIndex <= sourceIndex) {
              leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));
          }
          if (targetIndex > sourceIndex) {
              leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));
          }
          var rightBorder = right;
          if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {
              rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));
          }
          if (targetIndex < sourceIndex) {
              rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));
          }
          return {
              top: top,
              bottom: bottom,
              right: rightBorder,
              left: leftBorder,
          };
      });
  };

  var getTableColumnGeometries = function (columns, tableWidth) {
      var columnWidths = columns
          .map(function (column) { return column.width; });
      var freeSpace = tableWidth;
      var restrictedSpace = columnWidths
          .reduce(function (accum, width) { return accum + (width || 0); }, 0);
      var freeSpacePortions = columnWidths
          .reduce(function (accum, width) { return accum + (width === undefined ? 1 : 0); }, 0);
      var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;
      var lastRightPosition = 0;
      return columnWidths
          .map(function (width) { return (width === undefined ? freeSpacePortion : width); })
          .map(function (width) {
          lastRightPosition += width;
          return {
              left: lastRightPosition - width,
              right: lastRightPosition,
          };
      });
  };
  var getTableTargetColumnIndex = function (columnGeometries, sourceIndex, offset) { return getTargetColumnGeometries(columnGeometries, sourceIndex)
      .findIndex(function (_a) {
      var left = _a.left, right = _a.right;
      return offset > left && offset < right;
  }); };
  var ANIMATION_DURATION = 200;
  var getAnimationProgress = function (animation) { return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION; };
  var getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {
      var resizing = prevColumns.map(function (column) { return column.key; }).join()
          === nextColumns.map(function (column) { return column.key; }).join();
      var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth)
          .map(function (geometry, index) { return [prevColumns[index].key, geometry]; })
          .map(function (_a) {
          var _b = __read(_a, 2), key = _b[0], geometry = _b[1];
          var animation = prevAnimations.get(key);
          if (!animation)
              return [key, geometry];
          var progress = dxCore.easeOutCubic(getAnimationProgress(animation));
          var _c = animation.left, to = _c.to, from = _c.from;
          var left = ((to - from) * progress) + from;
          return [key, {
                  left: left,
                  right: geometry.right - (geometry.left - left),
              }];
          // tslint:disable-next-line:array-type
      }));
      var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)
          // tslint:disable-next-line:array-type
          .map(function (geometry, index) { return [nextColumns[index].key, geometry]; }));
      return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {
          var prev = prevColumnGeometries.get(key);
          var next = nextColumnGeometries.get(key);
          var result = { startTime: new Date().getTime(), style: {} };
          var takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);
          if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {
              result.left = { from: prev.left, to: next.left };
          }
          return [key, result];
      })
          .filter(function (animation) { return animation[1].left; }));
  };
  var filterActiveAnimations = function (animations) { return new Map(__spread(animations.entries()).filter(function (_a) {
      var _b = __read(_a, 2), animation = _b[1];
      return getAnimationProgress(animation) < 1;
  })); };
  var evalAnimations = function (animations) { return new Map(__spread(animations.entries()).map(function (_a) {
      var _b = __read(_a, 2), key = _b[0], animation = _b[1];
      var progress = dxCore.easeOutCubic(getAnimationProgress(animation));
      var result = __assign({}, animation.style);
      if (animation.left) {
          var offset = (animation.left.to - animation.left.from) * (progress - 1);
          result.transform = "translateX(" + offset + "px)";
      }
      return [key, result];
  })); };

  var isOnTheSameLine = function (geometry, y) { return (y >= geometry.top && y <= geometry.bottom); };
  var rectToObject = function (_a) {
      var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
      return ({
          top: top, right: right, bottom: bottom, left: left,
      });
  };
  var collapseGapsBetweenItems = function (geometries) { return (geometries.map(function (geometry, index) {
      if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {
          return __assign({}, geometry, { right: geometries[index + 1].left });
      }
      return geometry;
  })); };
  var getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {
      var x = _a.x, y = _a.y;
      if (geometries.length === 0)
          return 0;
      var targetGeometries = sourceIndex !== -1
          ? getTargetColumnGeometries(geometries, sourceIndex)
          : geometries.map(rectToObject);
      var targetIndex = collapseGapsBetweenItems(targetGeometries)
          .findIndex(function (geometry, index) {
          var inVerticalBounds = isOnTheSameLine(geometry, y);
          var inHorizontalBounds = x >= geometry.left && x <= geometry.right;
          var shouldGoFirst = index === 0 && x < geometry.left;
          var shouldGoOnLineBreak = !inVerticalBounds
              && !!geometries[index - 1]
              && isOnTheSameLine(geometries[index - 1], y);
          return (inVerticalBounds && inHorizontalBounds)
              || shouldGoFirst
              || shouldGoOnLineBreak;
      });
      return targetIndex === -1 ? geometries.length : targetIndex;
  };

  /** how many rows up and down before next page request */
  var pageTriggersMeta = function (_a, _b) {
      var containerHeight = _a.containerHeight, visibleRowBoundaries = _a.visibleRowBoundaries, estimatedRowHeight = _a.estimatedRowHeight;
      var pageSize = _b.pageSize, virtualRows = _b.virtualRows;
      var loadedCount = virtualRows.rows.length;
      if (loadedCount === 0) {
          return null;
      }
      var loadedRowsStart = virtualRows.skip;
      var topTriggerIndex = loadedRowsStart > 0 ? loadedRowsStart + pageSize : 0;
      var bottomTriggerIndex = loadedRowsStart + loadedCount - pageSize;
      var bodyBoundaries = visibleRowBoundaries.body;
      var firstRowIndex = bodyBoundaries.start;
      var visibleCount = bodyBoundaries.end - bodyBoundaries.start;
      var middleIndex = firstRowIndex + Math.round(visibleCount / 2);
      var middlePosition = visibleRowBoundaries.viewportTop + containerHeight / 2;
      var topTriggerOffset = (middleIndex - topTriggerIndex) * estimatedRowHeight;
      var bottomTriggerOffset = (bottomTriggerIndex - middleIndex) * estimatedRowHeight;
      var topTriggerPosition = middlePosition - topTriggerOffset;
      var bottomTriggerPosition = middlePosition + bottomTriggerOffset;
      return {
          topTriggerIndex: topTriggerIndex,
          topTriggerPosition: topTriggerPosition,
          bottomTriggerIndex: bottomTriggerIndex,
          bottomTriggerPosition: bottomTriggerPosition,
      };
  };

  var getVisibleRowsBounds = function (state, getters, estimatedRowHeight, getRowHeight) {
      var viewportTop = state.viewportTop, containerHeight = state.containerHeight, headerHeight = state.headerHeight, footerHeight = state.footerHeight;
      var loadedRowsStart = getters.loadedRowsStart, bodyRows = getters.bodyRows, _a = getters.headerRows, headerRows = _a === void 0 ? [] : _a, _b = getters.footerRows, footerRows = _b === void 0 ? [] : _b;
      return {
          viewportTop: viewportTop,
          header: getRowsVisibleBoundary(headerRows, 0, headerHeight, getRowHeight, 0, estimatedRowHeight),
          body: getRowsVisibleBoundary(bodyRows, viewportTop, containerHeight - headerHeight - footerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight),
          footer: getRowsVisibleBoundary(footerRows, 0, footerHeight, getRowHeight, 0, estimatedRowHeight),
      };
  };
  var nextPageReferenceIndex = function (payload, getters) {
      var triggersMeta = pageTriggersMeta(payload, getters);
      if (triggersMeta === null) {
          return null;
      }
      var topTriggerPosition = triggersMeta.topTriggerPosition, bottomTriggerPosition = triggersMeta.bottomTriggerPosition, topTriggerIndex = triggersMeta.topTriggerIndex, bottomTriggerIndex = triggersMeta.bottomTriggerIndex;
      var viewportTop = payload.viewportTop, estimatedRowHeight = payload.estimatedRowHeight, containerHeight = payload.containerHeight;
      var referencePosition = viewportTop + containerHeight / 2;
      var getReferenceIndex = function (triggetIndex, triggerPosition) { return (triggetIndex + Math.round((referencePosition - triggerPosition) / estimatedRowHeight)); };
      var referenceIndex = null;
      if (referencePosition < topTriggerPosition) {
          referenceIndex = getReferenceIndex(topTriggerIndex, topTriggerPosition);
      }
      if (bottomTriggerPosition < referencePosition) {
          referenceIndex = getReferenceIndex(bottomTriggerIndex, bottomTriggerPosition);
      }
      return referenceIndex;
  };

  var empty = {
      start: Number.POSITIVE_INFINITY,
      end: Number.NEGATIVE_INFINITY,
  };
  var getRowsInterval = function (r) { return (r === emptyVirtualRows
      ? empty
      : {
          start: r.skip,
          end: r.skip + r.rows.length,
      }); };
  var getLength = function (a) { return a.end - a.start; };
  var intersect = function (a, b) {
      if (a.end < b.start || b.end < a.start) {
          return empty;
      }
      return {
          start: Math.max(a.start, b.start),
          end: Math.min(a.end, b.end),
      };
  };
  var difference = function (a, b) {
      if (empty === intervalUtil.intersect(a, b)) {
          return a;
      }
      if (b.end < a.end) {
          return {
              start: b.end,
              end: a.end,
          };
      }
      if (a.start < b.start) {
          return {
              start: a.start,
              end: b.start,
          };
      }
      return empty;
  };
  var intervalUtil = {
      empty: empty,
      getRowsInterval: getRowsInterval,
      getLength: getLength,
      intersect: intersect,
      difference: difference,
  };

  var emptyVirtualRows = {
      skip: Number.POSITIVE_INFINITY,
      rows: [],
  };
  var pluckSubarray = function (source, sourceStart, left, right) { return (source.slice(left - sourceStart, right - sourceStart)); };
  var mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {
      var breakpoints = [
          rowsInterval.start, rowsInterval.end,
          cacheInterval.start, cacheInterval.end,
      ]
          .filter(function (i) { return 0 <= i && i < Number.POSITIVE_INFINITY; })
          .sort(function (a, b) { return a - b; });
      var result = [];
      if (breakpoints.length > 1) {
          for (var i = 0; i < breakpoints.length - 1; i += 1) {
              var left = breakpoints[i];
              var right = breakpoints[i + 1];
              var chunk = rowsInterval.start <= left && right <= rowsInterval.end
                  ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority
                  : pluckSubarray(cacheRows, cacheStart, left, right);
              result = result.concat(chunk);
          }
      }
      return {
          skip: breakpoints[0],
          rows: result,
      };
  };
  var calculateRequestedRange = function (loadedInterval, newRange, referenceIndex, pageSize) {
      if (Math.abs(loadedInterval.start - newRange.start) >= 2 * pageSize) {
          var useFirstHalf = referenceIndex % pageSize < pageSize / 2;
          var start = useFirstHalf
              ? newRange.start
              : newRange.start + pageSize;
          var end = Math.min(newRange.end, start + 2 * pageSize);
          return { start: start, end: end };
      }
      return intervalUtil.difference(newRange, loadedInterval);
  };
  var rowToPageIndex = function (rowIndex, pageSize) { return Math.floor(rowIndex / pageSize); };
  var recalculateBounds = function (middleIndex, pageSize, totalCount) {
      var currentPageIndex = rowToPageIndex(middleIndex, pageSize);
      var prevPageIndex = currentPageIndex - 1;
      var nextPageIndex = currentPageIndex + 2;
      var start = Math.max(0, prevPageIndex * pageSize);
      var end = Math.min(nextPageIndex * pageSize, totalCount);
      return {
          start: start,
          end: end,
      };
  };
  var trimRowsToInterval = function (virtualRows, targetInterval) {
      var rowsInterval = intervalUtil.getRowsInterval(virtualRows);
      var intersection = intervalUtil.intersect(rowsInterval, targetInterval);
      if (intervalUtil.empty === intersection) {
          return emptyVirtualRows;
      }
      var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);
      return {
          rows: rows,
          skip: intersection.start,
      };
  };
  var getAvailableRowCount = function (infiniteScroll, newCount, lastCount, totalRowCount) { return (infiniteScroll
      ? Math.max(newCount, lastCount)
      : totalRowCount); };

  var virtualRowsWithCache = function (skip, rows, cache) {
      var rowsInterval = intervalUtil.getRowsInterval({ skip: skip, rows: rows });
      var cacheInterval = intervalUtil.getRowsInterval(cache);
      return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);
  };
  var plainRows = function (virtualRows) { return virtualRows.rows; };
  var loadedRowsStart = function (virtualRows) { return virtualRows.skip; };

  /** @internal */

  exports.BAND_DUPLICATE_RENDER = BAND_DUPLICATE_RENDER;
  exports.BAND_EMPTY_CELL = BAND_EMPTY_CELL;
  exports.BAND_GROUP_CELL = BAND_GROUP_CELL;
  exports.BAND_HEADER_CELL = BAND_HEADER_CELL;
  exports.DEFAULT_FILTER_OPERATIONS = DEFAULT_FILTER_OPERATIONS;
  exports.FIXED_COLUMN_LEFT_SIDE = FIXED_COLUMN_LEFT_SIDE;
  exports.FIXED_COLUMN_RIGHT_SIDE = FIXED_COLUMN_RIGHT_SIDE;
  exports.GROUP_KEY_SEPARATOR = GROUP_KEY_SEPARATOR;
  exports.TABLE_ADDED_TYPE = TABLE_ADDED_TYPE;
  exports.TABLE_BAND_TYPE = TABLE_BAND_TYPE;
  exports.TABLE_DATA_TYPE = TABLE_DATA_TYPE;
  exports.TABLE_DETAIL_TYPE = TABLE_DETAIL_TYPE;
  exports.TABLE_EDIT_COMMAND_TYPE = TABLE_EDIT_COMMAND_TYPE;
  exports.TABLE_EDIT_TYPE = TABLE_EDIT_TYPE;
  exports.TABLE_FILTER_TYPE = TABLE_FILTER_TYPE;
  exports.TABLE_FIXED_TYPE = TABLE_FIXED_TYPE;
  exports.TABLE_FLEX_TYPE = TABLE_FLEX_TYPE;
  exports.TABLE_GROUP_SUMMARY_TYPE = TABLE_GROUP_SUMMARY_TYPE;
  exports.TABLE_GROUP_TYPE = TABLE_GROUP_TYPE;
  exports.TABLE_HEADING_TYPE = TABLE_HEADING_TYPE;
  exports.TABLE_NODATA_TYPE = TABLE_NODATA_TYPE;
  exports.TABLE_REORDERING_TYPE = TABLE_REORDERING_TYPE;
  exports.TABLE_SELECT_TYPE = TABLE_SELECT_TYPE;
  exports.TABLE_STUB_TYPE = TABLE_STUB_TYPE;
  exports.TABLE_TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE;
  exports.TABLE_TREE_SUMMARY_TYPE = TABLE_TREE_SUMMARY_TYPE;
  exports.addRow = addRow;
  exports.addedRowsByIds = addedRowsByIds;
  exports.adjustSortIndex = adjustSortIndex;
  exports.allSelected = allSelected;
  exports.calculateFixedColumnProps = calculateFixedColumnProps;
  exports.calculateKeepOther = calculateKeepOther;
  exports.calculateRequestedRange = calculateRequestedRange;
  exports.calculateStartPage = calculateStartPage;
  exports.cancelAddedRows = cancelAddedRows;
  exports.cancelChanges = cancelChanges;
  exports.cancelColumnGroupingDraft = cancelColumnGroupingDraft;
  exports.cancelDeletedRows = cancelDeletedRows;
  exports.cancelTableColumnWidthDraft = cancelTableColumnWidthDraft;
  exports.cellValueGetter = cellValueGetter;
  exports.changeAddedRow = changeAddedRow;
  exports.changeColumnFilter = changeColumnFilter;
  exports.changeColumnGrouping = changeColumnGrouping;
  exports.changeColumnOrder = changeColumnOrder;
  exports.changeColumnSorting = changeColumnSorting;
  exports.changeRow = changeRow;
  exports.changeSearchValue = changeSearchValue;
  exports.changeTableColumnWidth = changeTableColumnWidth;
  exports.changedRowsByIds = changedRowsByIds;
  exports.clamp = clamp;
  exports.collapsedTreeRowsGetter = collapsedTreeRowsGetter;
  exports.columnChooserItems = columnChooserItems;
  exports.createRowChangeGetter = createRowChangeGetter;
  exports.currentPage = currentPage;
  exports.customGroupedRows = customGroupedRows;
  exports.customGroupingRowIdGetter = customGroupingRowIdGetter;
  exports.customTreeRowIdGetter = customTreeRowIdGetter;
  exports.customTreeRowLevelKeyGetter = customTreeRowLevelKeyGetter;
  exports.customTreeRowsWithMeta = customTreeRowsWithMeta;
  exports.defaultFilterPredicate = defaultFilterPredicate;
  exports.defaultSummaryCalculator = defaultSummaryCalculator;
  exports.deleteRows = deleteRows;
  exports.draftColumnGrouping = draftColumnGrouping;
  exports.draftOrder = draftOrder;
  exports.draftTableColumnWidth = draftTableColumnWidth;
  exports.emptyVirtualRows = emptyVirtualRows;
  exports.evalAnimations = evalAnimations;
  exports.expandedGroupRows = expandedGroupRows;
  exports.expandedTreeRows = expandedTreeRows;
  exports.filterActiveAnimations = filterActiveAnimations;
  exports.filterExpression = filterExpression;
  exports.filteredCollapsedRowsGetter = filteredCollapsedRowsGetter;
  exports.filteredRows = filteredRows;
  exports.findChainByColumnIndex = findChainByColumnIndex;
  exports.firstRowOnPage = firstRowOnPage;
  exports.generateSimpleChains = generateSimpleChains;
  exports.getAnimations = getAnimations;
  exports.getAvailableFilterOperationsGetter = getAvailableFilterOperationsGetter;
  exports.getAvailableRowCount = getAvailableRowCount;
  exports.getBandComponent = getBandComponent;
  exports.getCollapsedGrid = getCollapsedGrid;
  exports.getCollapsedGrids = getCollapsedGrids;
  exports.getColumnBoundaries = getColumnBoundaries;
  exports.getColumnExtension = getColumnExtension;
  exports.getColumnExtensionValueGetter = getColumnExtensionValueGetter;
  exports.getColumnFilterConfig = getColumnFilterConfig;
  exports.getColumnFilterOperations = getColumnFilterOperations;
  exports.getColumnMeta = getColumnMeta;
  exports.getColumnSortingDirection = getColumnSortingDirection;
  exports.getColumnSummaries = getColumnSummaries;
  exports.getColumnWidthGetter = getColumnWidthGetter;
  exports.getColumnsRenderBoundary = getColumnsRenderBoundary;
  exports.getFixedColumnKeys = getFixedColumnKeys;
  exports.getGroupCellTargetIndex = getGroupCellTargetIndex;
  exports.getPersistentSortedColumns = getPersistentSortedColumns;
  exports.getRowChange = getRowChange;
  exports.getRowsRenderBoundary = getRowsRenderBoundary;
  exports.getRowsVisibleBoundary = getRowsVisibleBoundary;
  exports.getSelectedFilterOperation = getSelectedFilterOperation;
  exports.getTableColumnGeometries = getTableColumnGeometries;
  exports.getTableTargetColumnIndex = getTableTargetColumnIndex;
  exports.getTreeRowLevelGetter = getTreeRowLevelGetter;
  exports.getVisibleRowsBounds = getVisibleRowsBounds;
  exports.groupCollapsedRowsGetter = groupCollapsedRowsGetter;
  exports.groupRowChecker = groupRowChecker;
  exports.groupRowLevelKeyGetter = groupRowLevelKeyGetter;
  exports.groupSummaryValues = groupSummaryValues;
  exports.groupedRows = groupedRows;
  exports.groupingPanelItems = groupingPanelItems;
  exports.intervalUtil = intervalUtil;
  exports.isAddedTableRow = isAddedTableRow;
  exports.isBandedOrHeaderRow = isBandedOrHeaderRow;
  exports.isBandedTableRow = isBandedTableRow;
  exports.isDataTableCell = isDataTableCell;
  exports.isDataTableRow = isDataTableRow;
  exports.isDetailRowExpanded = isDetailRowExpanded;
  exports.isDetailTableCell = isDetailTableCell;
  exports.isDetailTableRow = isDetailTableRow;
  exports.isDetailToggleTableCell = isDetailToggleTableCell;
  exports.isEditCommandsTableCell = isEditCommandsTableCell;
  exports.isEditTableCell = isEditTableCell;
  exports.isEditTableRow = isEditTableRow;
  exports.isFilterTableCell = isFilterTableCell;
  exports.isFilterTableRow = isFilterTableRow;
  exports.isFilterValueEmpty = isFilterValueEmpty;
  exports.isFixedTableRow = isFixedTableRow;
  exports.isGroupIndentTableCell = isGroupIndentTableCell;
  exports.isGroupSummaryTableCell = isGroupSummaryTableCell;
  exports.isGroupSummaryTableRow = isGroupSummaryTableRow;
  exports.isGroupTableCell = isGroupTableCell;
  exports.isGroupTableRow = isGroupTableRow;
  exports.isHeaderStubTableCell = isHeaderStubTableCell;
  exports.isHeadingEditCommandsTableCell = isHeadingEditCommandsTableCell;
  exports.isHeadingTableCell = isHeadingTableCell;
  exports.isHeadingTableRow = isHeadingTableRow;
  exports.isNoDataColumn = isNoDataColumn;
  exports.isNoDataTableCell = isNoDataTableCell;
  exports.isNoDataTableRow = isNoDataTableRow;
  exports.isSelectAllTableCell = isSelectAllTableCell;
  exports.isSelectTableCell = isSelectTableCell;
  exports.isStubTableCell = isStubTableCell;
  exports.isTotalSummaryTableCell = isTotalSummaryTableCell;
  exports.isTotalSummaryTableRow = isTotalSummaryTableRow;
  exports.isTreeRowLeafGetter = isTreeRowLeafGetter;
  exports.isTreeSummaryTableCell = isTreeSummaryTableCell;
  exports.isTreeSummaryTableRow = isTreeSummaryTableRow;
  exports.isTreeTableCell = isTreeTableCell;
  exports.lastRowOnPage = lastRowOnPage;
  exports.loadedRowsStart = loadedRowsStart;
  exports.mergeRows = mergeRows;
  exports.nextPageReferenceIndex = nextPageReferenceIndex;
  exports.orderedColumns = orderedColumns;
  exports.pageCount = pageCount;
  exports.pageTriggersMeta = pageTriggersMeta;
  exports.paginatedRows = paginatedRows;
  exports.plainRows = plainRows;
  exports.recalculateBounds = recalculateBounds;
  exports.rowCount = rowCount;
  exports.rowIdGetter = rowIdGetter;
  exports.rowToPageIndex = rowToPageIndex;
  exports.rowsWithAvailableToSelect = rowsWithAvailableToSelect;
  exports.rowsWithPageHeaders = rowsWithPageHeaders;
  exports.searchFilterExpression = searchFilterExpression;
  exports.setCurrentPage = setCurrentPage;
  exports.setPageSize = setPageSize;
  exports.someSelected = someSelected;
  exports.sortedRows = sortedRows;
  exports.splitHeaderColumnChains = splitHeaderColumnChains;
  exports.startEditRows = startEditRows;
  exports.stopEditRows = stopEditRows;
  exports.tableCellColSpanGetter = tableCellColSpanGetter;
  exports.tableColumnsWithDataRows = tableColumnsWithDataRows;
  exports.tableColumnsWithDetail = tableColumnsWithDetail;
  exports.tableColumnsWithDraftWidths = tableColumnsWithDraftWidths;
  exports.tableColumnsWithEditing = tableColumnsWithEditing;
  exports.tableColumnsWithFixed = tableColumnsWithFixed;
  exports.tableColumnsWithGrouping = tableColumnsWithGrouping;
  exports.tableColumnsWithSelection = tableColumnsWithSelection;
  exports.tableColumnsWithWidths = tableColumnsWithWidths;
  exports.tableDataColumnsExist = tableDataColumnsExist;
  exports.tableDetailCellColSpanGetter = tableDetailCellColSpanGetter;
  exports.tableGroupCellColSpanGetter = tableGroupCellColSpanGetter;
  exports.tableHeaderColumnChainsWithBands = tableHeaderColumnChainsWithBands;
  exports.tableHeaderColumnChainsWithFixed = tableHeaderColumnChainsWithFixed;
  exports.tableHeaderRowsWithFilter = tableHeaderRowsWithFilter;
  exports.tableHeaderRowsWithFixed = tableHeaderRowsWithFixed;
  exports.tableHeaderRowsWithReordering = tableHeaderRowsWithReordering;
  exports.tableRowsWithBands = tableRowsWithBands;
  exports.tableRowsWithDataRows = tableRowsWithDataRows;
  exports.tableRowsWithEditing = tableRowsWithEditing;
  exports.tableRowsWithExpandedDetail = tableRowsWithExpandedDetail;
  exports.tableRowsWithGrouping = tableRowsWithGrouping;
  exports.tableRowsWithHeading = tableRowsWithHeading;
  exports.tableRowsWithSummaries = tableRowsWithSummaries;
  exports.tableRowsWithTotalSummaries = tableRowsWithTotalSummaries;
  exports.toggleColumn = toggleColumn;
  exports.toggleDetailRowExpanded = toggleDetailRowExpanded;
  exports.toggleExpandedGroups = toggleExpandedGroups;
  exports.toggleRowExpanded = toggleRowExpanded;
  exports.toggleSelection = toggleSelection;
  exports.totalSummaryValues = totalSummaryValues;
  exports.treeSummaryValues = treeSummaryValues;
  exports.trimRowsToInterval = trimRowsToInterval;
  exports.unwrapSelectedRows = unwrapSelectedRows;
  exports.unwrappedCustomTreeRows = unwrappedCustomTreeRows;
  exports.unwrappedFilteredRows = unwrappedFilteredRows;
  exports.virtualRowsWithCache = virtualRowsWithCache;
  exports.visibleTableColumns = visibleTableColumns;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=dx-grid-core.umd.js.map
