/**
 * Bundle of @devexpress/dx-react-grid
 * Generated: 2019-05-17
 * Version: 1.11.0
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('@devexpress/dx-react-core'), require('@devexpress/dx-grid-core'), require('@devexpress/dx-core'), require('react-dom')) :
    typeof define === 'function' && define.amd ? define(['exports', 'react', '@devexpress/dx-react-core', '@devexpress/dx-grid-core', '@devexpress/dx-core', 'react-dom'], factory) :
    (global = global || self, factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXReactGrid = {}), global.React, global.DevExpress.DXReactCore, global.DevExpress.DXGridCore, global.DevExpress.DXCore, global.ReactDOM));
}(this, function (exports, React, dxReactCore, dxGridCore, dxCore, reactDom) { 'use strict';

    if (typeof process === "undefined") { var process = { env: {} }; }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var GridCore = /*#__PURE__*/ (function (_super) {
        __extends(GridCore, _super);
        function GridCore() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GridCore.prototype.render = function () {
            var _a = this.props, rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue, Root = _a.rootComponent;
            return (React.createElement(dxReactCore.Plugin, null,
                React.createElement(dxReactCore.Getter, { name: "skip", value: 0 }),
                React.createElement(dxReactCore.Getter, { name: "loadedRowsStart", value: 0 }),
                React.createElement(dxReactCore.Getter, { name: "rows", value: rows }),
                React.createElement(dxReactCore.Getter, { name: "getRowId", value: dxGridCore.rowIdGetter(getRowId, rows) }),
                React.createElement(dxReactCore.Getter, { name: "columns", value: columns }),
                React.createElement(dxReactCore.Getter, { name: "getCellValue", value: dxGridCore.cellValueGetter(getCellValue, columns) }),
                React.createElement(dxReactCore.Template, { name: "root" },
                    React.createElement(Root, null,
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: "header" }),
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: "body" }),
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: "footer" })))));
        };
        return GridCore;
    }(React.PureComponent));

    var GridBase = function (_a) {
        var rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue, rootComponent = _a.rootComponent, children = _a.children;
        return (React.createElement(dxReactCore.PluginHost, null,
            React.createElement(GridCore, { rows: rows, columns: columns, getRowId: getRowId, getCellValue: getCellValue, rootComponent: rootComponent }),
            children));
    };
    /***
     * The Grid is a root container component designed to process and display data specified via
     * the `rows` property. You can configure columns using the `columns` property. The Grid's
     * functionality  is implemented in several plugins specified as child components.
     * See the plugins concept for details.
     * */
    var Grid = GridBase;

    var pluginDependencies = [
        { name: 'TableColumnVisibility' },
        { name: 'Toolbar' },
    ];
    var ColumnChooserBase = /*#__PURE__*/ (function (_super) {
        __extends(ColumnChooserBase, _super);
        function ColumnChooserBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                visible: false,
            };
            _this.handleToggle = _this.handleToggle.bind(_this);
            _this.handleHide = _this.handleHide.bind(_this);
            _this.setButtonRef = _this.setButtonRef.bind(_this);
            return _this;
        }
        ColumnChooserBase.prototype.setButtonRef = function (button) {
            this.button = button;
        };
        ColumnChooserBase.prototype.handleToggle = function () {
            var visible = this.state.visible;
            this.setState({ visible: !visible });
        };
        ColumnChooserBase.prototype.handleHide = function () {
            this.setState({ visible: false });
        };
        ColumnChooserBase.prototype.render = function () {
            var _this = this;
            var _a = this.props, Overlay = _a.overlayComponent, Container = _a.containerComponent, Item = _a.itemComponent, ToggleButton = _a.toggleButtonComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(messages);
            var visible = this.state.visible;
            return (React.createElement(dxReactCore.Plugin, { name: "ColumnChooser", dependencies: pluginDependencies },
                React.createElement(dxReactCore.Template, { name: "toolbarContent" },
                    React.createElement(dxReactCore.TemplatePlaceholder, null),
                    React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                        var columns = _a.columns, hiddenColumnNames = _a.hiddenColumnNames, isColumnTogglingEnabled = _a.isColumnTogglingEnabled;
                        var toggleColumnVisibility = _b.toggleColumnVisibility;
                        return (React.createElement(React.Fragment, null,
                            React.createElement(ToggleButton, { buttonRef: _this.setButtonRef, onToggle: _this.handleToggle, getMessage: getMessage, active: visible }),
                            React.createElement(Overlay, { visible: visible, target: _this.button, onHide: _this.handleHide },
                                React.createElement(Container, null, dxGridCore.columnChooserItems(columns, hiddenColumnNames)
                                    .map(function (item) {
                                    var columnName = item.column.name;
                                    var togglingEnabled = isColumnTogglingEnabled(columnName);
                                    return (React.createElement(Item, { key: columnName, item: item, disabled: !togglingEnabled, onToggle: function () { return toggleColumnVisibility(columnName); } }));
                                })))));
                    }))));
        };
        ColumnChooserBase.defaultProps = {
            messages: {},
        };
        ColumnChooserBase.components = {
            overlayComponent: 'Overlay',
            containerComponent: 'Container',
            itemComponent: 'Item',
            toggleButtonComponent: 'ToggleButton',
        };
        return ColumnChooserBase;
    }(React.PureComponent));
    /***
     * The ColumnChooser plugin allows a user to toggle grid columns' visibility at runtime.
     * The column chooser lists columns with checkboxes that control a corresponding
     * column's visibility.
     * */
    var ColumnChooser = ColumnChooserBase;

    var columnExtensionValueGetter = function (columnExtensions, defaultValue) { return (dxGridCore.getColumnExtensionValueGetter(columnExtensions, 'filteringEnabled', defaultValue)); };
    var filterExpressionComputed = function (_a) {
        var filters = _a.filters, filterExpressionValue = _a.filterExpression;
        return dxGridCore.filterExpression(filters, filterExpressionValue);
    };
    var FilteringStateBase = /*#__PURE__*/ (function (_super) {
        __extends(FilteringStateBase, _super);
        function FilteringStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                filters: props.filters || props.defaultFilters,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                filters: function () {
                    var onFiltersChange = _this.props.onFiltersChange;
                    return onFiltersChange;
                },
            });
            _this.changeColumnFilter = stateHelper.applyFieldReducer
                .bind(stateHelper, 'filters', dxGridCore.changeColumnFilter);
            return _this;
        }
        // tslint:disable-next-line:member-ordering
        FilteringStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.filters, filters = _a === void 0 ? prevState.filters : _a;
            return {
                filters: filters,
            };
        };
        FilteringStateBase.prototype.render = function () {
            var filters = this.state.filters;
            var _a = this.props, columnExtensions = _a.columnExtensions, columnFilteringEnabled = _a.columnFilteringEnabled;
            return (React.createElement(dxReactCore.Plugin, { name: "FilteringState" },
                React.createElement(dxReactCore.Getter, { name: "filters", value: filters }),
                React.createElement(dxReactCore.Getter, { name: "filterExpression", computed: filterExpressionComputed }),
                React.createElement(dxReactCore.Getter, { name: "isColumnFilteringEnabled", value: columnExtensionValueGetter(columnExtensions, columnFilteringEnabled) }),
                React.createElement(dxReactCore.Action, { name: "changeColumnFilter", action: this.changeColumnFilter })));
        };
        FilteringStateBase.defaultProps = {
            defaultFilters: [],
            columnFilteringEnabled: true,
        };
        return FilteringStateBase;
    }(React.PureComponent));
    /** A plugin that manages the filtering state. */
    var FilteringState = FilteringStateBase;

    var pluginDependencies$1 = [
        { name: 'FilteringState', optional: true },
        { name: 'SearchState', optional: true },
    ];
    var getCollapsedRowsComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.filteredCollapsedRowsGetter(rows);
    };
    var unwrappedRowsComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.unwrappedFilteredRows(rows);
    };
    var IntegratedFilteringBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedFilteringBase, _super);
        function IntegratedFilteringBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedFilteringBase.prototype.render = function () {
            var columnExtensions = this.props.columnExtensions;
            var getColumnPredicate = function (columnName) { return dxGridCore.getColumnExtension(columnExtensions, columnName).predicate; };
            var rowsComputed = function (_a) {
                var rows = _a.rows, filterExpression = _a.filterExpression, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, getCollapsedRows = _a.getCollapsedRows;
                return dxGridCore.filteredRows(rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedFiltering", dependencies: pluginDependencies$1 },
                React.createElement(dxReactCore.Getter, { name: "rows", computed: rowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: unwrappedRowsComputed })));
        };
        return IntegratedFilteringBase;
    }(React.PureComponent));
    IntegratedFilteringBase.defaultPredicate = dxGridCore.defaultFilterPredicate;
    var IntegratedFiltering = IntegratedFilteringBase;

    var columnExtensionValueGetter$1 = function (columnExtensions, defaultValue) { return dxGridCore.getColumnExtensionValueGetter(columnExtensions, 'editingEnabled', defaultValue); };
    var EditingStateBase = /*#__PURE__*/ (function (_super) {
        __extends(EditingStateBase, _super);
        function EditingStateBase(props) {
            var _this = _super.call(this, props) || this;
            var rowChanges = props.rowChanges || props.defaultRowChanges;
            var addedRows = props.addedRows || props.defaultAddedRows;
            var getRowChanges = function () {
                var stateRowChanges = _this.state.rowChanges;
                return stateRowChanges;
            };
            var getAddedRows = function () {
                var stateAddedRows = _this.state.addedRows;
                return stateAddedRows;
            };
            _this.state = {
                addedRows: addedRows,
                rowChanges: rowChanges,
                editingRowIds: props.editingRowIds || props.defaultEditingRowIds,
                deletedRowIds: props.deletedRowIds || props.defaultDeletedRowIds,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                editingRowIds: function () {
                    var onEditingRowIdsChange = _this.props.onEditingRowIdsChange;
                    return onEditingRowIdsChange;
                },
                addedRows: function () {
                    var onAddedRowsChange = _this.props.onAddedRowsChange;
                    return onAddedRowsChange;
                },
                rowChanges: function () {
                    var onRowChangesChange = _this.props.onRowChangesChange;
                    return onRowChangesChange;
                },
                deletedRowIds: function () {
                    var onDeletedRowIdsChange = _this.props.onDeletedRowIdsChange;
                    return onDeletedRowIdsChange;
                },
            });
            _this.startEditRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'editingRowIds', dxGridCore.startEditRows);
            _this.stopEditRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'editingRowIds', dxGridCore.stopEditRows);
            _this.changeRow = stateHelper.applyFieldReducer
                .bind(stateHelper, 'rowChanges', dxGridCore.changeRow);
            _this.cancelChangedRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'rowChanges', dxGridCore.cancelChanges);
            _this.commitChangedRows = function (_a) {
                var rowIds = _a.rowIds;
                var onCommitChanges = _this.props.onCommitChanges;
                onCommitChanges({
                    changed: dxGridCore.changedRowsByIds(getRowChanges(), rowIds),
                });
                _this.cancelChangedRows({ rowIds: rowIds });
            };
            _this.addRow = stateHelper.applyFieldReducer
                .bind(stateHelper, 'addedRows', dxGridCore.addRow);
            _this.changeAddedRow = stateHelper.applyFieldReducer
                .bind(stateHelper, 'addedRows', dxGridCore.changeAddedRow);
            _this.cancelAddedRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'addedRows', dxGridCore.cancelAddedRows);
            _this.commitAddedRows = function (_a) {
                var rowIds = _a.rowIds;
                var onCommitChanges = _this.props.onCommitChanges;
                onCommitChanges({
                    added: dxGridCore.addedRowsByIds(getAddedRows(), rowIds),
                });
                _this.cancelAddedRows({ rowIds: rowIds });
            };
            _this.deleteRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'deletedRowIds', dxGridCore.deleteRows);
            _this.cancelDeletedRows = stateHelper.applyFieldReducer
                .bind(stateHelper, 'deletedRowIds', dxGridCore.cancelDeletedRows);
            _this.commitDeletedRows = function (_a) {
                var rowIds = _a.rowIds;
                var onCommitChanges = _this.props.onCommitChanges;
                onCommitChanges({ deleted: rowIds });
                _this.cancelDeletedRows({ rowIds: rowIds });
            };
            return _this;
        }
        EditingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.editingRowIds, editingRowIds = _a === void 0 ? prevState.editingRowIds : _a, _b = nextProps.rowChanges, rowChanges = _b === void 0 ? prevState.rowChanges : _b, _c = nextProps.addedRows, addedRows = _c === void 0 ? prevState.addedRows : _c, _d = nextProps.deletedRowIds, deletedRowIds = _d === void 0 ? prevState.deletedRowIds : _d;
            return {
                editingRowIds: editingRowIds,
                rowChanges: rowChanges,
                addedRows: addedRows,
                deletedRowIds: deletedRowIds,
            };
        };
        EditingStateBase.prototype.render = function () {
            var _a = this.props, createRowChange = _a.createRowChange, columnExtensions = _a.columnExtensions, columnEditingEnabled = _a.columnEditingEnabled;
            var _b = this.state, editingRowIds = _b.editingRowIds, rowChanges = _b.rowChanges, addedRows = _b.addedRows, deletedRowIds = _b.deletedRowIds;
            return (React.createElement(dxReactCore.Plugin, { name: "EditingState" },
                React.createElement(dxReactCore.Getter, { name: "createRowChange", value: dxGridCore.createRowChangeGetter(createRowChange, columnExtensions) }),
                React.createElement(dxReactCore.Getter, { name: "editingRowIds", value: editingRowIds }),
                React.createElement(dxReactCore.Action, { name: "startEditRows", action: this.startEditRows }),
                React.createElement(dxReactCore.Action, { name: "stopEditRows", action: this.stopEditRows }),
                React.createElement(dxReactCore.Getter, { name: "rowChanges", value: rowChanges }),
                React.createElement(dxReactCore.Action, { name: "changeRow", action: this.changeRow }),
                React.createElement(dxReactCore.Action, { name: "cancelChangedRows", action: this.cancelChangedRows }),
                React.createElement(dxReactCore.Action, { name: "commitChangedRows", action: this.commitChangedRows }),
                React.createElement(dxReactCore.Getter, { name: "addedRows", value: addedRows }),
                React.createElement(dxReactCore.Action, { name: "addRow", action: this.addRow }),
                React.createElement(dxReactCore.Action, { name: "changeAddedRow", action: this.changeAddedRow }),
                React.createElement(dxReactCore.Action, { name: "cancelAddedRows", action: this.cancelAddedRows }),
                React.createElement(dxReactCore.Action, { name: "commitAddedRows", action: this.commitAddedRows }),
                React.createElement(dxReactCore.Getter, { name: "deletedRowIds", value: deletedRowIds }),
                React.createElement(dxReactCore.Action, { name: "deleteRows", action: this.deleteRows }),
                React.createElement(dxReactCore.Action, { name: "cancelDeletedRows", action: this.cancelDeletedRows }),
                React.createElement(dxReactCore.Action, { name: "commitDeletedRows", action: this.commitDeletedRows }),
                React.createElement(dxReactCore.Getter, { name: "isColumnEditingEnabled", value: columnExtensionValueGetter$1(columnExtensions, columnEditingEnabled) })));
        };
        EditingStateBase.defaultProps = {
            columnEditingEnabled: true,
            defaultEditingRowIds: [],
            defaultRowChanges: {},
            defaultAddedRows: [],
            defaultDeletedRowIds: [],
        };
        return EditingStateBase;
    }(React.PureComponent));
    /***
     * A plugin that manages grid rows' editing state. It arranges grid rows
     * by different lists depending on a row's state.
     * */
    var EditingState = EditingStateBase;

    var PagingStateBase = /*#__PURE__*/ (function (_super) {
        __extends(PagingStateBase, _super);
        function PagingStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                currentPage: props.currentPage || props.defaultCurrentPage,
                pageSize: props.pageSize !== undefined ? props.pageSize : props.defaultPageSize,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                currentPage: function () {
                    var onCurrentPageChange = _this.props.onCurrentPageChange;
                    return onCurrentPageChange;
                },
                pageSize: function () {
                    var onPageSizeChange = _this.props.onPageSizeChange;
                    return onPageSizeChange;
                },
            });
            _this.setCurrentPage = stateHelper.applyFieldReducer
                .bind(stateHelper, 'currentPage', dxGridCore.setCurrentPage);
            _this.setPageSize = stateHelper.applyFieldReducer
                .bind(stateHelper, 'pageSize', dxGridCore.setPageSize);
            return _this;
        }
        PagingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.currentPage, currentPage = _a === void 0 ? prevState.currentPage : _a, _b = nextProps.pageSize, pageSize = _b === void 0 ? prevState.pageSize : _b;
            return {
                currentPage: currentPage,
                pageSize: pageSize,
            };
        };
        PagingStateBase.prototype.render = function () {
            var _a = this.state, pageSize = _a.pageSize, currentPage = _a.currentPage;
            return (React.createElement(dxReactCore.Plugin, { name: "PagingState" },
                React.createElement(dxReactCore.Getter, { name: "currentPage", value: currentPage }),
                React.createElement(dxReactCore.Getter, { name: "pageSize", value: pageSize }),
                React.createElement(dxReactCore.Action, { name: "setCurrentPage", action: this.setCurrentPage }),
                React.createElement(dxReactCore.Action, { name: "setPageSize", action: this.setPageSize })));
        };
        PagingStateBase.defaultProps = {
            defaultPageSize: 10,
            defaultCurrentPage: 0,
        };
        return PagingStateBase;
    }(React.PureComponent));
    /***
     * A plugin that manages the paging state. It controls the total page count depending on the
     * total row count and the specified page size, controls the currently selected page number
     * and changes it in response to the corresponding actions.
     * */
    var PagingState = PagingStateBase;

    var pluginDependencies$2 = [
        { name: 'PagingState' },
    ];
    var rowsWithHeadersComputed = function (_a) {
        var rows = _a.rows, pageSize = _a.pageSize, getRowLevelKey = _a.getRowLevelKey;
        return dxGridCore.rowsWithPageHeaders(rows, pageSize, getRowLevelKey);
    };
    var totalCountComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.rowCount(rows);
    };
    var paginatedRowsComputed = function (_a) {
        var rows = _a.rows, pageSize = _a.pageSize, page = _a.currentPage;
        return dxGridCore.paginatedRows(rows, pageSize, page);
    };
    var currentPageComputed = function (_a, _b) {
        var page = _a.currentPage, totalCount = _a.totalCount, pageSize = _a.pageSize;
        var setCurrentPage = _b.setCurrentPage;
        return dxGridCore.currentPage(page, totalCount, pageSize, setCurrentPage);
    };
    // eslint-disable-next-line react/prefer-stateless-function
    var IntegratedPagingBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedPagingBase, _super);
        function IntegratedPagingBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedPagingBase.prototype.render = function () {
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedPaging", dependencies: pluginDependencies$2 },
                React.createElement(dxReactCore.Getter, { name: "rows", computed: rowsWithHeadersComputed }),
                React.createElement(dxReactCore.Getter, { name: "totalCount", computed: totalCountComputed }),
                React.createElement(dxReactCore.Getter, { name: "currentPage", computed: currentPageComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: paginatedRowsComputed })));
        };
        return IntegratedPagingBase;
    }(React.PureComponent));
    /***
     * A plugin that performs built-in data paging. It also changes the current page if the provided
     * one cannot be applied due to fewer available pages.
     * */
    var IntegratedPaging = IntegratedPagingBase;

    var pluginDependencies$3 = [
        { name: 'PagingState' },
    ];
    var CustomPagingBase = /*#__PURE__*/ (function (_super) {
        __extends(CustomPagingBase, _super);
        function CustomPagingBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomPagingBase.prototype.render = function () {
            var totalCount = this.props.totalCount;
            return (React.createElement(dxReactCore.Plugin, { name: "CustomPaging", dependencies: pluginDependencies$3 },
                React.createElement(dxReactCore.Getter, { name: "totalCount", value: totalCount })));
        };
        CustomPagingBase.defaultProps = {
            totalCount: 0,
        };
        return CustomPagingBase;
    }(React.PureComponent));
    /** A plugin that allows implementing a custom totalCount calculation logic. */
    var CustomPaging = CustomPagingBase;

    var dependencies = [
        { name: 'SortingState', optional: true },
    ];
    var columnExtensionValueGetter$2 = function (columnExtensions, defaultValue) { return dxGridCore.getColumnExtensionValueGetter(columnExtensions, 'groupingEnabled', defaultValue); };
    var GroupingStateBase = /*#__PURE__*/ (function (_super) {
        __extends(GroupingStateBase, _super);
        function GroupingStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                grouping: props.grouping || props.defaultGrouping,
                draftGrouping: null,
                expandedGroups: props.expandedGroups || props.defaultExpandedGroups,
            };
            _this.stateHelper = dxReactCore.createStateHelper(_this, {
                grouping: function () {
                    var onGroupingChange = _this.props.onGroupingChange;
                    return onGroupingChange;
                },
                expandedGroups: function () {
                    var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;
                    return onExpandedGroupsChange;
                },
            });
            _this.changeColumnGrouping = _this.changeColumnGrouping.bind(_this);
            _this.toggleGroupExpanded = _this.stateHelper.applyReducer
                .bind(_this.stateHelper, dxGridCore.toggleExpandedGroups);
            _this.draftColumnGrouping = _this.stateHelper.applyReducer
                .bind(_this.stateHelper, dxGridCore.draftColumnGrouping);
            _this.cancelColumnGroupingDraft = _this.stateHelper.applyReducer
                .bind(_this.stateHelper, dxGridCore.cancelColumnGroupingDraft);
            _this.changeColumnSorting = _this.changeColumnSorting.bind(_this);
            return _this;
        }
        GroupingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.grouping, grouping = _a === void 0 ? prevState.grouping : _a, _b = nextProps.expandedGroups, expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;
            return {
                grouping: grouping,
                expandedGroups: expandedGroups,
            };
        };
        GroupingStateBase.prototype.changeColumnSorting = function (_a, _b, _c) {
            var sorting = _b.sorting;
            var changeColumnSorting = _c.changeColumnSorting;
            var columnName = _a.columnName, keepOther = _a.keepOther, restParams = __rest(_a, ["columnName", "keepOther"]);
            var grouping = this.state.grouping;
            var groupingIndex = grouping
                .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
            if (groupingIndex === -1) {
                changeColumnSorting(__assign({ columnName: columnName, keepOther: keepOther || grouping.map(function (columnGrouping) { return columnGrouping.columnName; }) }, restParams));
                return false;
            }
            var sortIndex = dxGridCore.adjustSortIndex(groupingIndex, grouping, sorting);
            changeColumnSorting(__assign({ columnName: columnName,
                sortIndex: sortIndex, keepOther: true }, restParams));
            return false;
        };
        GroupingStateBase.prototype.changeColumnGrouping = function (_a, getters, actions) {
            var columnName = _a.columnName, groupIndex = _a.groupIndex;
            this.stateHelper.applyReducer(dxGridCore.changeColumnGrouping, { columnName: columnName, groupIndex: groupIndex }, function (nextState, state) {
                var grouping = nextState.grouping;
                var prevGrouping = state.grouping;
                var sorting = getters.sorting;
                var changeColumnSorting = actions.changeColumnSorting;
                if (!sorting)
                    return;
                var columnSortingIndex = sorting
                    .findIndex(function (columnSorting) { return columnSorting.columnName === columnName; });
                var prevGroupingIndex = prevGrouping
                    .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
                var groupingIndex = grouping
                    .findIndex(function (columnGrouping) { return columnGrouping.columnName === columnName; });
                if (columnSortingIndex === -1
                    || (prevGroupingIndex === prevGrouping.length - 1 && groupingIndex === -1))
                    return;
                var sortIndex = dxGridCore.adjustSortIndex(groupingIndex === -1 ? grouping.length : groupingIndex, grouping, sorting);
                if (columnSortingIndex === sortIndex)
                    return;
                changeColumnSorting(__assign({ sortIndex: sortIndex, keepOther: true }, sorting[columnSortingIndex]));
            });
        };
        GroupingStateBase.prototype.render = function () {
            var _a = this.state, grouping = _a.grouping, draftGrouping = _a.draftGrouping, expandedGroups = _a.expandedGroups;
            var _b = this.props, columnExtensions = _b.columnExtensions, columnGroupingEnabled = _b.columnGroupingEnabled;
            return (React.createElement(dxReactCore.Plugin, { name: "GroupingState", dependencies: dependencies },
                React.createElement(dxReactCore.Getter, { name: "grouping", value: grouping }),
                React.createElement(dxReactCore.Getter, { name: "draftGrouping", value: draftGrouping || grouping }),
                React.createElement(dxReactCore.Getter, { name: "isColumnGroupingEnabled", value: columnExtensionValueGetter$2(columnExtensions, columnGroupingEnabled) }),
                React.createElement(dxReactCore.Action, { name: "changeColumnGrouping", action: this.changeColumnGrouping }),
                React.createElement(dxReactCore.Action, { name: "draftColumnGrouping", action: this.draftColumnGrouping }),
                React.createElement(dxReactCore.Action, { name: "cancelColumnGroupingDraft", action: this.cancelColumnGroupingDraft }),
                React.createElement(dxReactCore.Getter, { name: "expandedGroups", value: expandedGroups }),
                React.createElement(dxReactCore.Action, { name: "toggleGroupExpanded", action: this.toggleGroupExpanded }),
                React.createElement(dxReactCore.Action, { name: "changeColumnSorting", action: this.changeColumnSorting })));
        };
        GroupingStateBase.defaultProps = {
            defaultGrouping: [],
            defaultExpandedGroups: [],
            columnGroupingEnabled: true,
        };
        return GroupingStateBase;
    }(React.PureComponent));
    /***
     * A plugin that manages the grouping state. It lists columns used for grouping and stores
     * information about expanded/collapsed groups.
     * */
    var GroupingState = GroupingStateBase;

    var pluginDependencies$4 = [
        { name: 'GroupingState' },
    ];
    var getCollapsedRowsComputed$1 = function (_a) {
        var getCollapsedRows = _a.getCollapsedRows;
        return dxGridCore.groupCollapsedRowsGetter(getCollapsedRows);
    };
    var expandedGroupedRowsComputed = function (_a) {
        var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups;
        return dxGridCore.expandedGroupRows(rows, grouping, expandedGroups);
    };
    var IntegratedGroupingBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedGroupingBase, _super);
        function IntegratedGroupingBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedGroupingBase.prototype.render = function () {
            var columnExtensions = this.props.columnExtensions;
            var getColumnCriteria = function (columnName) { return dxGridCore.getColumnExtension(columnExtensions, columnName).criteria; };
            var groupedRowsComputed = function (_a) {
                var rows = _a.rows, grouping = _a.grouping, getCellValue = _a.getCellValue;
                return dxGridCore.groupedRows(rows, grouping, getCellValue, getColumnCriteria);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedGrouping", dependencies: pluginDependencies$4 },
                React.createElement(dxReactCore.Getter, { name: "isGroupRow", value: dxGridCore.groupRowChecker }),
                React.createElement(dxReactCore.Getter, { name: "getRowLevelKey", value: dxGridCore.groupRowLevelKeyGetter }),
                React.createElement(dxReactCore.Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$1 }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: groupedRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: expandedGroupedRowsComputed })));
        };
        return IntegratedGroupingBase;
    }(React.PureComponent));
    /* tslint:disable: max-line-length */
    /** A plugin that performs built-in grouping and group expanding/collapsing. */
    var IntegratedGrouping = IntegratedGroupingBase;
    /* tslint:enable: max-line-length */

    var pluginDependencies$5 = [
        { name: 'GroupingState' },
    ];
    var getCollapsedRowsComputed$2 = function (_a) {
        var getCollapsedRows = _a.getCollapsedRows;
        return dxGridCore.groupCollapsedRowsGetter(getCollapsedRows);
    };
    var expandedGroupedRowsComputed$1 = function (_a) {
        var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups;
        return dxGridCore.expandedGroupRows(rows, grouping, expandedGroups);
    };
    var getRowIdComputed = function (_a) {
        var getRowId = _a.getRowId, rows = _a.rows;
        return dxGridCore.customGroupingRowIdGetter(getRowId, rows);
    };
    var CustomGroupingBase = /*#__PURE__*/ (function (_super) {
        __extends(CustomGroupingBase, _super);
        function CustomGroupingBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomGroupingBase.prototype.render = function () {
            var _a = this.props, getChildGroups = _a.getChildGroups, appliedGrouping = _a.grouping, appliedExpandedGroups = _a.expandedGroups;
            var groupedRowsComputed = function (_a) {
                var rows = _a.rows, grouping = _a.grouping;
                return dxGridCore.customGroupedRows(rows, grouping, getChildGroups);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "CustomGrouping", dependencies: pluginDependencies$5 },
                appliedGrouping && (React.createElement(dxReactCore.Getter, { name: "grouping", value: appliedGrouping })),
                appliedExpandedGroups && (React.createElement(dxReactCore.Getter, { name: "expandedGroups", value: appliedExpandedGroups })),
                React.createElement(dxReactCore.Getter, { name: "isGroupRow", value: dxGridCore.groupRowChecker }),
                React.createElement(dxReactCore.Getter, { name: "getRowLevelKey", value: dxGridCore.groupRowLevelKeyGetter }),
                React.createElement(dxReactCore.Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$2 }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: groupedRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getRowId", computed: getRowIdComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: expandedGroupedRowsComputed$1 })));
        };
        return CustomGroupingBase;
    }(React.PureComponent));
    // tslint:disable-next-line: max-line-length
    /** A plugin that converts custom formatted grouped data to a supported format and performs local group expanding/collapsing. */
    var CustomGrouping = CustomGroupingBase;

    var SelectionStateBase = /*#__PURE__*/ (function (_super) {
        __extends(SelectionStateBase, _super);
        function SelectionStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                selection: props.selection || props.defaultSelection,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                selection: function () {
                    var onSelectionChange = _this.props.onSelectionChange;
                    return onSelectionChange;
                },
            });
            _this.toggleSelection = stateHelper.applyFieldReducer
                .bind(stateHelper, 'selection', dxGridCore.toggleSelection);
            return _this;
        }
        SelectionStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.selection, selection = _a === void 0 ? prevState.selection : _a;
            return {
                selection: selection,
            };
        };
        SelectionStateBase.prototype.render = function () {
            var selection = this.state.selection;
            return (React.createElement(dxReactCore.Plugin, { name: "SelectionState" },
                React.createElement(dxReactCore.Getter, { name: "selection", value: selection }),
                React.createElement(dxReactCore.Action, { name: "toggleSelection", action: this.toggleSelection })));
        };
        SelectionStateBase.defaultProps = {
            defaultSelection: [],
        };
        return SelectionStateBase;
    }(React.PureComponent));
    /** A plugin that manages the selection state. */
    var SelectionState = SelectionStateBase;

    var rowsWithAvailableToSelectComputed = function (_a) {
        var rows = _a.rows, getRowId = _a.getRowId, isGroupRow = _a.isGroupRow;
        return dxGridCore.rowsWithAvailableToSelect(rows, getRowId, isGroupRow);
    };
    var allSelectedComputed = function (_a) {
        var rows = _a.rows, selection = _a.selection;
        return dxGridCore.allSelected(rows, selection);
    };
    var someSelectedComputed = function (_a) {
        var rows = _a.rows, selection = _a.selection;
        return dxGridCore.someSelected(rows, selection);
    };
    var selectAllAvailableComputed = function (_a) {
        var availableToSelect = _a.rows.availableToSelect;
        return !!availableToSelect.length;
    };
    var toggleSelectAll = function (state, _a, _b) {
        var availableToSelect = _a.rows.availableToSelect;
        var toggleSelection = _b.toggleSelection;
        toggleSelection({ state: state, rowIds: availableToSelect });
    };
    var unwrapRowsComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.unwrapSelectedRows(rows);
    };
    var pluginDependencies$6 = [
        { name: 'SelectionState' },
    ];
    // eslint-disable-next-line react/prefer-stateless-function
    var IntegratedSelectionBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedSelectionBase, _super);
        function IntegratedSelectionBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedSelectionBase.prototype.render = function () {
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedSelection", dependencies: pluginDependencies$6 },
                React.createElement(dxReactCore.Getter, { name: "rows", computed: rowsWithAvailableToSelectComputed }),
                React.createElement(dxReactCore.Getter, { name: "allSelected", computed: allSelectedComputed }),
                React.createElement(dxReactCore.Getter, { name: "someSelected", computed: someSelectedComputed }),
                React.createElement(dxReactCore.Getter, { name: "selectAllAvailable", computed: selectAllAvailableComputed }),
                React.createElement(dxReactCore.Action, { name: "toggleSelectAll", action: toggleSelectAll }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: unwrapRowsComputed })));
        };
        return IntegratedSelectionBase;
    }(React.PureComponent));
    /* tslint:disable: max-line-length */
    /** A plugin that performs built-in selection. */
    var IntegratedSelection = IntegratedSelectionBase;
    /* tslint:enable: max-line-length */

    var columnExtensionValueGetter$3 = function (columnExtensions, defaultValue) { return dxGridCore.getColumnExtensionValueGetter(columnExtensions, 'sortingEnabled', defaultValue); };
    var SortingStateBase = /*#__PURE__*/ (function (_super) {
        __extends(SortingStateBase, _super);
        function SortingStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                sorting: props.sorting || props.defaultSorting,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                sorting: function () {
                    var onSortingChange = _this.props.onSortingChange;
                    return onSortingChange;
                },
            });
            _this.changeColumnSorting = stateHelper.applyReducer
                .bind(stateHelper, function (prevState, payload) {
                var _a = _this.props.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
                var persistentSortedColumns = dxGridCore.getPersistentSortedColumns(sorting, props.columnExtensions);
                var keepOther = dxGridCore.calculateKeepOther(prevState.sorting, payload.keepOther, persistentSortedColumns);
                return dxGridCore.changeColumnSorting(prevState, __assign({}, payload, { keepOther: keepOther }));
            });
            return _this;
        }
        SortingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
            return {
                sorting: sorting,
            };
        };
        SortingStateBase.prototype.render = function () {
            var sorting = this.state.sorting;
            var _a = this.props, columnExtensions = _a.columnExtensions, columnSortingEnabled = _a.columnSortingEnabled;
            return (React.createElement(dxReactCore.Plugin, { name: "SortingState" },
                React.createElement(dxReactCore.Getter, { name: "sorting", value: sorting }),
                React.createElement(dxReactCore.Getter, { name: "isColumnSortingEnabled", value: columnExtensionValueGetter$3(columnExtensions, columnSortingEnabled) }),
                React.createElement(dxReactCore.Action, { name: "changeColumnSorting", action: this.changeColumnSorting })));
        };
        SortingStateBase.defaultProps = {
            defaultSorting: [],
            columnSortingEnabled: true,
        };
        return SortingStateBase;
    }(React.PureComponent));
    // tslint:disable-next-line: max-line-length
    /** A plugin that manages the sorting state. It controls the list of columns that participate in sorting. */
    var SortingState = SortingStateBase;

    var pluginDependencies$7 = [
        { name: 'SortingState' },
    ];
    var IntegratedSortingBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedSortingBase, _super);
        function IntegratedSortingBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedSortingBase.prototype.render = function () {
            var columnExtensions = this.props.columnExtensions;
            var getColumnCompare = function (columnName) { return dxGridCore.getColumnExtension(columnExtensions, columnName).compare; };
            var rowsComputed = function (_a) {
                var rows = _a.rows, sorting = _a.sorting, getCellValue = _a.getCellValue, isGroupRow = _a.isGroupRow, getRowLevelKey = _a.getRowLevelKey;
                return dxGridCore.sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedSorting", dependencies: pluginDependencies$7 },
                React.createElement(dxReactCore.Getter, { name: "rows", computed: rowsComputed })));
        };
        return IntegratedSortingBase;
    }(React.PureComponent));
    /** A plugin that performs built-in data sorting. */
    var IntegratedSorting = IntegratedSortingBase;

    var getTargetColumns = function (payload, columns) { return payload
        .filter(function (item) { return item.type === 'column'; })
        .map(function (item) { return columns.find(function (column) { return column.name === item.columnName; }); }); };
    // tslint:disable-next-line: max-line-length
    var DragDropProviderBase = /*#__PURE__*/ (function (_super) {
        __extends(DragDropProviderBase, _super);
        function DragDropProviderBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                payload: null,
                clientOffset: null,
            };
            _this.change = function (_a) {
                var payload = _a.payload, clientOffset = _a.clientOffset;
                return _this.setState({ payload: payload, clientOffset: clientOffset });
            };
            return _this;
        }
        DragDropProviderBase.prototype.render = function () {
            var _a = this.props, Container = _a.containerComponent, Column = _a.columnComponent;
            var _b = this.state, payload = _b.payload, clientOffset = _b.clientOffset;
            return (React.createElement(dxReactCore.Plugin, { name: "DragDropProvider" },
                React.createElement(dxReactCore.Getter, { name: "draggingEnabled", value: true }),
                React.createElement(dxReactCore.Template, { name: "root" },
                    React.createElement(dxReactCore.DragDropProvider, { onChange: this.change },
                        React.createElement(dxReactCore.TemplatePlaceholder, null)),
                    payload && (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                        var columns = _a.columns;
                        return (React.createElement(Container, { clientOffset: clientOffset }, getTargetColumns(payload, columns)
                            .map(function (column) { return (React.createElement(Column, { key: column.name, column: column })); })));
                    })))));
        };
        DragDropProviderBase.components = {
            containerComponent: 'Container',
            columnComponent: 'Column',
        };
        return DragDropProviderBase;
    }(React.PureComponent));
    // tslint:disable-next-line: max-line-length
    /** A plugin that implements the drag-and-drop functionality and visualizes columns that are being dragged. */
    var DragDropProvider = DragDropProviderBase;

    var pluginDependencies$8 = [
        { name: 'Table' },
        { name: 'DragDropProvider', optional: true },
    ];
    var tableHeaderRowsComputed = function (_a) {
        var tableHeaderRows = _a.tableHeaderRows;
        return dxGridCore.tableHeaderRowsWithReordering(tableHeaderRows);
    };
    // tslint:disable-next-line: max-line-length
    var TableColumnReorderingRaw = /*#__PURE__*/ (function (_super) {
        __extends(TableColumnReorderingRaw, _super);
        function TableColumnReorderingRaw(props) {
            var _this = _super.call(this, props) || this;
            _this.cellDimensionGetters = {};
            _this.cellDimensions = [];
            _this.state = {
                order: props.defaultOrder,
                sourceColumnIndex: -1,
                targetColumnIndex: -1,
            };
            _this.onOver = _this.handleOver.bind(_this);
            _this.onLeave = _this.handleLeave.bind(_this);
            _this.onDrop = _this.handleDrop.bind(_this);
            return _this;
        }
        TableColumnReorderingRaw.prototype.getState = function () {
            var orderState = this.state.order;
            var _a = this.props.order, order = _a === void 0 ? orderState : _a;
            return __assign({}, this.state, { order: order });
        };
        TableColumnReorderingRaw.prototype.getDraftOrder = function () {
            var _a = this.getState(), order = _a.order, sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex;
            return dxGridCore.draftOrder(order, sourceColumnIndex, targetColumnIndex);
        };
        TableColumnReorderingRaw.prototype.getAvailableColumns = function () {
            var _this = this;
            return this.getDraftOrder()
                .filter(function (columnName) { return !!_this.cellDimensionGetters[columnName]; });
        };
        TableColumnReorderingRaw.prototype.cacheCellDimensions = function () {
            var _this = this;
            this.cellDimensions = (this.cellDimensions && this.cellDimensions.length)
                ? this.cellDimensions
                : this.getAvailableColumns()
                    .map(function (columnName) { return _this.cellDimensionGetters[columnName](); });
        };
        TableColumnReorderingRaw.prototype.resetCellDimensions = function () {
            this.cellDimensions = [];
        };
        TableColumnReorderingRaw.prototype.ensureCellDimensionGetters = function (tableColumns) {
            var _this = this;
            Object.keys(this.cellDimensionGetters)
                .forEach(function (columnName) {
                var columnIndex = tableColumns
                    .findIndex(function (_a) {
                    var type = _a.type, column = _a.column;
                    return type === dxGridCore.TABLE_DATA_TYPE && column.name === columnName;
                });
                if (columnIndex === -1) {
                    delete _this.cellDimensionGetters[columnName];
                }
            });
        };
        // tslint:disable-next-line: max-line-length
        TableColumnReorderingRaw.prototype.storeCellDimensionsGetter = function (tableColumn, getter, tableColumns) {
            if (tableColumn.type === dxGridCore.TABLE_DATA_TYPE) {
                this.cellDimensionGetters[tableColumn.column.name] = getter;
            }
            this.ensureCellDimensionGetters(tableColumns);
        };
        TableColumnReorderingRaw.prototype.handleOver = function (_a) {
            var payload = _a.payload, x = _a.clientOffset.x;
            var sourceColumnName = payload[0].columnName;
            var availableColumns = this.getAvailableColumns();
            var relativeSourceColumnIndex = availableColumns.indexOf(sourceColumnName);
            if (relativeSourceColumnIndex === -1)
                return;
            this.cacheCellDimensions();
            var cellDimensions = this.cellDimensions;
            var overlappedColumns = cellDimensions
                .filter(function (_a) {
                var left = _a.left, right = _a.right;
                return left <= x && x <= right;
            });
            if (overlappedColumns.length > 1)
                return;
            var relativeTargetIndex = dxGridCore.getTableTargetColumnIndex(cellDimensions, relativeSourceColumnIndex, x);
            if (relativeTargetIndex === -1)
                return;
            var _b = this.getState(), prevSourceColumnIndex = _b.sourceColumnIndex, prevTargetColumnIndex = _b.targetColumnIndex;
            var draftOrder = this.getDraftOrder();
            var targetColumnIndex = draftOrder.indexOf(availableColumns[relativeTargetIndex]);
            if (targetColumnIndex === prevTargetColumnIndex)
                return;
            var sourceColumnIndex = prevSourceColumnIndex === -1
                ? draftOrder.indexOf(sourceColumnName)
                : prevSourceColumnIndex;
            this.setState({
                sourceColumnIndex: sourceColumnIndex,
                targetColumnIndex: targetColumnIndex,
            });
        };
        TableColumnReorderingRaw.prototype.handleLeave = function () {
            this.setState({
                sourceColumnIndex: -1,
                targetColumnIndex: -1,
            });
            this.resetCellDimensions();
        };
        TableColumnReorderingRaw.prototype.handleDrop = function () {
            var _a = this.getState(), sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex, order = _a.order;
            var onOrderChange = this.props.onOrderChange;
            if (sourceColumnIndex === -1 && targetColumnIndex === -1)
                return;
            var nextOrder = dxGridCore.changeColumnOrder(order, {
                sourceColumnName: order[sourceColumnIndex],
                targetColumnName: order[targetColumnIndex],
            });
            this.setState({
                order: nextOrder,
                sourceColumnIndex: -1,
                targetColumnIndex: -1,
            });
            if (onOrderChange) {
                onOrderChange(nextOrder);
            }
            this.resetCellDimensions();
        };
        TableColumnReorderingRaw.prototype.render = function () {
            var _this = this;
            var _a = this.props, Container = _a.tableContainerComponent, Row = _a.rowComponent, Cell = _a.cellComponent;
            var columnsComputed = function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.orderedColumns(tableColumns, _this.getDraftOrder());
            };
            this.cellDimensionGetters = {};
            return (React.createElement(dxReactCore.Plugin, { name: "TableColumnReordering", dependencies: pluginDependencies$8 },
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: columnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
                React.createElement(dxReactCore.Template, { name: "table" }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var draggingEnabled = _a.draggingEnabled;
                    return (React.createElement(Container, __assign({}, params, { onOver: _this.onOver, onLeave: _this.onLeave, onDrop: _this.onDrop, draggingEnabled: draggingEnabled }),
                        React.createElement(dxReactCore.TemplatePlaceholder, null)));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return tableRow.type === dxGridCore.TABLE_REORDERING_TYPE;
                    } }, function (params) { return (React.createElement(Row, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return tableRow.type === dxGridCore.TABLE_REORDERING_TYPE;
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns;
                    return (React.createElement(Cell, __assign({}, params, { getCellDimensions: function (getter) { return _this.storeCellDimensionsGetter(params.tableColumn, getter, tableColumns); } })));
                })); })));
        };
        TableColumnReorderingRaw.defaultProps = {
            defaultOrder: [],
        };
        TableColumnReorderingRaw.components = {
            tableContainerComponent: 'TableContainer',
            rowComponent: 'Row',
            cellComponent: 'Cell',
        };
        return TableColumnReorderingRaw;
    }(React.PureComponent));
    var TableContainer = function (_a) {
        var onOver = _a.onOver, onLeave = _a.onLeave, onDrop = _a.onDrop, children = _a.children, draggingEnabled = _a.draggingEnabled;
        return (draggingEnabled ? (React.createElement(dxReactCore.DropTarget, { onOver: onOver, onLeave: onLeave, onDrop: onDrop }, children)) : children);
    };
    /** A plugin that manages the displayed columns' order. */
    var TableColumnReordering = dxReactCore.withComponents({ TableContainer: TableContainer })(TableColumnReorderingRaw);

    var RowPlaceholder = function (props) { return React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableRow", params: props }); };
    var CellPlaceholder = function (props) { return React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableCell", params: props }); };
    var tableHeaderRows = [];
    var tableBodyRowsComputed = function (_a) {
        var rows = _a.rows, getRowId = _a.getRowId, isDataLoading = _a.isDataLoading;
        return (dxGridCore.tableRowsWithDataRows(rows, getRowId, isDataLoading));
    };
    var tableFooterRows = [];
    var defaultMessages = {
        noData: 'No data',
    };
    var TableBase = /*#__PURE__*/ (function (_super) {
        __extends(TableBase, _super);
        function TableBase(props) {
            var _this = _super.call(this, props) || this;
            _this.tableColumnsComputed = dxCore.memoize(function (columnExtensions) { return function (_a) {
                var columns = _a.columns;
                return dxGridCore.tableColumnsWithDataRows(columns, columnExtensions);
            }; });
            return _this;
        }
        TableBase.prototype.render = function () {
            var _a = this.props, Layout = _a.layoutComponent, Cell = _a.cellComponent, Row = _a.rowComponent, NoDataRow = _a.noDataRowComponent, NoDataCell = _a.noDataCellComponent, StubRow = _a.stubRowComponent, StubCell = _a.stubCellComponent, StubHeaderCell = _a.stubHeaderCellComponent, columnExtensions = _a.columnExtensions, messages = _a.messages, containerComponent = _a.containerComponent, tableComponent = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages, messages));
            var tableColumnsComputed = this.tableColumnsComputed(columnExtensions);
            return (React.createElement(dxReactCore.Plugin, { name: "Table" },
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", value: tableHeaderRows }),
                React.createElement(dxReactCore.Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableFooterRows", value: tableFooterRows }),
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getTableCellColSpan", value: dxGridCore.tableCellColSpanGetter }),
                React.createElement(dxReactCore.Getter, { name: "visibleBoundaries", value: [] }),
                React.createElement(dxReactCore.Template, { name: "body" },
                    React.createElement(dxReactCore.TemplatePlaceholder, { name: "table" })),
                React.createElement(dxReactCore.Template, { name: "table" },
                    React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                        var headerRows = _a.tableHeaderRows, bodyRows = _a.tableBodyRows, footerRows = _a.tableFooterRows, columns = _a.tableColumns, getTableCellColSpan = _a.getTableCellColSpan;
                        return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableLayout", params: {
                                tableComponent: tableComponent,
                                headComponent: headComponent,
                                bodyComponent: bodyComponent,
                                footerComponent: footerComponent,
                                containerComponent: containerComponent,
                                headerRows: headerRows,
                                bodyRows: bodyRows,
                                footerRows: footerRows,
                                columns: columns,
                                rowComponent: RowPlaceholder,
                                cellComponent: CellPlaceholder,
                                getCellColSpan: getTableCellColSpan,
                            } }));
                    })),
                React.createElement(dxReactCore.Template, { name: "tableLayout" }, function (params) { return (React.createElement(Layout, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableCell" }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var headerRows = _a.tableHeaderRows;
                    return (dxGridCore.isHeaderStubTableCell(params.tableRow, headerRows)
                        ? React.createElement(StubHeaderCell, __assign({}, params))
                        : React.createElement(StubCell, __assign({}, params)));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isDataTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var getCellValue = _a.getCellValue;
                    var columnName = params.tableColumn.column.name;
                    var value = getCellValue(params.tableRow.row, columnName);
                    return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "valueFormatter", params: {
                            value: value,
                            row: params.tableRow.row,
                            column: params.tableColumn.column,
                        } }, function (content) { return (React.createElement(Cell, __assign({}, params, { row: params.tableRow.row, column: params.tableColumn.column, value: value }), content)); }));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isNoDataTableRow(tableRow);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns;
                    if (dxGridCore.isNoDataTableCell(params.tableColumn, tableColumns)) {
                        return (React.createElement(NoDataCell, __assign({}, params, { getMessage: getMessage })));
                    }
                    return null;
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow" }, function (params) { return (React.createElement(StubRow, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isDataTableRow(tableRow);
                    } }, function (params) { return (React.createElement(Row, __assign({}, params, { row: params.tableRow.row }))); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isNoDataTableRow(tableRow);
                    } }, function (params) { return React.createElement(NoDataRow, __assign({}, params)); })));
        };
        TableBase.COLUMN_TYPE = dxGridCore.TABLE_DATA_TYPE;
        TableBase.ROW_TYPE = dxGridCore.TABLE_DATA_TYPE;
        TableBase.NODATA_ROW_TYPE = dxGridCore.TABLE_NODATA_TYPE;
        TableBase.defaultProps = {
            messages: {},
        };
        TableBase.components = {
            tableComponent: 'Table',
            headComponent: 'TableHead',
            bodyComponent: 'TableBody',
            footerComponent: 'TableFooter',
            containerComponent: 'Container',
            layoutComponent: 'Layout',
            rowComponent: 'Row',
            cellComponent: 'Cell',
            noDataRowComponent: 'NoDataRow',
            noDataCellComponent: 'NoDataCell',
            stubRowComponent: 'StubRow',
            stubCellComponent: 'StubCell',
            stubHeaderCellComponent: 'StubHeaderCell',
        };
        return TableBase;
    }(React.PureComponent));
    /***
     * A plugin that renders Grid data as a table. This plugin enables you to customize
     * table rows and columns, and contains the Table Row and Table Cell components
     * that can be extended by other plugins
     * */
    var Table = TableBase;

    var TableSelectionBase = /*#__PURE__*/ (function (_super) {
        __extends(TableSelectionBase, _super);
        function TableSelectionBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableSelectionBase.prototype.render = function () {
            var _a = this.props, highlightRow = _a.highlightRow, selectByRowClick = _a.selectByRowClick, showSelectionColumn = _a.showSelectionColumn, showSelectAll = _a.showSelectAll, HeaderCell = _a.headerCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, selectionColumnWidth = _a.selectionColumnWidth;
            var tableColumnsComputed = function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithSelection(tableColumns, selectionColumnWidth);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableSelection", dependencies: [
                    { name: 'Table' },
                    { name: 'SelectionState' },
                    { name: 'IntegratedSelection', optional: !showSelectAll },
                ] },
                showSelectionColumn && (React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed })),
                (showSelectionColumn && showSelectAll) && (React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isSelectAllTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var selectAllAvailable = _a.selectAllAvailable, allSelected = _a.allSelected, someSelected = _a.someSelected;
                    var toggleSelectAll = _b.toggleSelectAll;
                    return (React.createElement(HeaderCell, __assign({}, params, { disabled: !selectAllAvailable, allSelected: allSelected, someSelected: someSelected, onToggle: function (select) { return toggleSelectAll(select); } })));
                })); })),
                showSelectionColumn && (React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isSelectTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var selection = _a.selection;
                    var toggleSelection = _b.toggleSelection;
                    return (React.createElement(Cell, __assign({}, params, { row: params.tableRow.row, selected: selection.indexOf(params.tableRow.rowId) !== -1, onToggle: function () { return toggleSelection({ rowIds: [params.tableRow.rowId] }); } })));
                })); })),
                (highlightRow || selectByRowClick) && (React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isDataTableRow(tableRow);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var selection = _a.selection;
                    var toggleSelection = _b.toggleSelection;
                    return (React.createElement(Row, __assign({}, params, { selectByRowClick: selectByRowClick, selected: highlightRow && selection.indexOf(params.tableRow.rowId) !== -1, onToggle: function () { return toggleSelection({ rowIds: [params.tableRow.rowId] }); } })));
                })); }))));
        };
        TableSelectionBase.defaultProps = {
            highlightRow: false,
            selectByRowClick: false,
            showSelectAll: false,
            showSelectionColumn: true,
        };
        TableSelectionBase.components = {
            rowComponent: 'Row',
            cellComponent: 'Cell',
            headerCellComponent: 'HeaderCell',
        };
        TableSelectionBase.COLUMN_TYPE = dxGridCore.TABLE_SELECT_TYPE;
        return TableSelectionBase;
    }(React.PureComponent));
    /***
     * A plugin that visualizes table rows' selection state by rendering selection checkboxes
     * and highlighting the selected rows.
     * */
    var TableSelection = TableSelectionBase;

    // tslint:disable-next-line: max-line-length
    var RowDetailStateBase = /*#__PURE__*/ (function (_super) {
        __extends(RowDetailStateBase, _super);
        function RowDetailStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                expandedRowIds: function () {
                    var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
                    return onExpandedRowIdsChange;
                },
            });
            _this.toggleDetailRowExpanded = stateHelper.applyFieldReducer
                .bind(stateHelper, 'expandedRowIds', dxGridCore.toggleDetailRowExpanded);
            return _this;
        }
        RowDetailStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
            return {
                expandedRowIds: expandedRowIds,
            };
        };
        RowDetailStateBase.prototype.render = function () {
            var expandedRowIds = this.state.expandedRowIds;
            return (React.createElement(dxReactCore.Plugin, { name: "RowDetailState" },
                React.createElement(dxReactCore.Getter, { name: "expandedDetailRowIds", value: expandedRowIds }),
                React.createElement(dxReactCore.Action, { name: "toggleDetailRowExpanded", action: this.toggleDetailRowExpanded })));
        };
        RowDetailStateBase.defaultProps = {
            defaultExpandedRowIds: [],
        };
        return RowDetailStateBase;
    }(React.PureComponent));
    /** A plugin that manages the expanded state for table row details. */
    var RowDetailState = RowDetailStateBase;

    var getCellColSpanComputed = function (_a) {
        var getTableCellColSpan = _a.getTableCellColSpan;
        return dxGridCore.tableDetailCellColSpanGetter(getTableCellColSpan);
    };
    var pluginDependencies$9 = [
        { name: 'RowDetailState' },
        { name: 'Table' },
    ];
    var TableRowDetailBase = /*#__PURE__*/ (function (_super) {
        __extends(TableRowDetailBase, _super);
        function TableRowDetailBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableRowDetailBase.prototype.render = function () {
            var _a = this.props, rowHeight = _a.rowHeight, Content = _a.contentComponent, ToggleCell = _a.toggleCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, toggleColumnWidth = _a.toggleColumnWidth;
            var tableColumnsComputed = function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithDetail(tableColumns, toggleColumnWidth);
            };
            var tableBodyRowsComputed = function (_a) {
                var tableBodyRows = _a.tableBodyRows, expandedDetailRowIds = _a.expandedDetailRowIds;
                return dxGridCore.tableRowsWithExpandedDetail(tableBodyRows, expandedDetailRowIds, rowHeight);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableRowDetail", dependencies: pluginDependencies$9 },
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isDetailToggleTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var expandedDetailRowIds = _a.expandedDetailRowIds;
                    var toggleDetailRowExpanded = _b.toggleDetailRowExpanded;
                    return (React.createElement(ToggleCell, __assign({}, params, { row: params.tableRow.row, expanded: dxGridCore.isDetailRowExpanded(expandedDetailRowIds, params.tableRow.rowId), onToggle: function () { return toggleDetailRowExpanded({ rowId: params.tableRow.rowId }); } })));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isDetailTableRow(tableRow);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns;
                    if (dxGridCore.isDetailTableCell(params.tableColumn, tableColumns)) {
                        return (React.createElement(Cell, __assign({}, params, { row: params.tableRow.row }), Content && React.createElement(Content, { row: params.tableRow.row })));
                    }
                    return null;
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isDetailTableRow(tableRow);
                    } }, function (params) { return (React.createElement(Row, __assign({}, params, { row: params.tableRow.row }))); })));
        };
        TableRowDetailBase.ROW_TYPE = dxGridCore.TABLE_DETAIL_TYPE;
        TableRowDetailBase.COLUMN_TYPE = dxGridCore.TABLE_DETAIL_TYPE;
        TableRowDetailBase.defaultProps = {
            contentComponent: function () { return null; },
        };
        TableRowDetailBase.components = {
            rowComponent: 'Row',
            cellComponent: 'Cell',
            toggleCellComponent: 'ToggleCell',
        };
        return TableRowDetailBase;
    }(React.PureComponent));
    /** A plugin that renders detail rows. */
    var TableRowDetail = TableRowDetailBase;

    var pluginDependencies$a = [
        { name: 'GroupingState' },
        { name: 'Table' },
        { name: 'DataTypeProvider', optional: true },
        { name: 'TableSelection', optional: true },
    ];
    var tableBodyRowsComputed$1 = function (_a) {
        var tableBodyRows = _a.tableBodyRows, isGroupRow = _a.isGroupRow;
        return dxGridCore.tableRowsWithGrouping(tableBodyRows, isGroupRow);
    };
    var getCellColSpanComputed$1 = function (_a) {
        var getTableCellColSpan = _a.getTableCellColSpan;
        return dxGridCore.tableGroupCellColSpanGetter(getTableCellColSpan);
    };
    var showColumnWhenGroupedGetter = function (showColumnsWhenGrouped, columnExtensions) {
        if (columnExtensions === void 0) { columnExtensions = []; }
        var map = columnExtensions.reduce(function (acc, columnExtension) {
            acc[columnExtension.columnName] = columnExtension.showWhenGrouped;
            return acc;
        }, {});
        return function (columnName) { return map[columnName] || showColumnsWhenGrouped; };
    };
    var TableGroupRowBase = /*#__PURE__*/ (function (_super) {
        __extends(TableGroupRowBase, _super);
        function TableGroupRowBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableGroupRowBase.prototype.render = function () {
            var _a = this.props, GroupCell = _a.cellComponent, Content = _a.contentComponent, Icon = _a.iconComponent, GroupRow = _a.rowComponent, GroupIndentCell = _a.indentCellComponent, indentColumnWidth = _a.indentColumnWidth, showColumnsWhenGrouped = _a.showColumnsWhenGrouped, columnExtensions = _a.columnExtensions;
            var tableColumnsComputed = function (_a) {
                var columns = _a.columns, tableColumns = _a.tableColumns, grouping = _a.grouping, draftGrouping = _a.draftGrouping;
                return dxGridCore.tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions));
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableGroupRow", dependencies: pluginDependencies$a },
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$1 }),
                React.createElement(dxReactCore.Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed$1 }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return dxGridCore.isGroupTableRow(tableRow);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
                    var toggleGroupExpanded = _b.toggleGroupExpanded;
                    if (dxGridCore.isGroupTableCell(params.tableRow, params.tableColumn)) {
                        return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "valueFormatter", params: {
                                column: params.tableColumn.column,
                                value: params.tableRow.row.value,
                            } }, function (content) { return (React.createElement(GroupCell, __assign({}, params, { contentComponent: Content, iconComponent: Icon, row: params.tableRow.row, column: params.tableColumn.column, expanded: expandedGroups.indexOf(params.tableRow.row.compoundKey) !== -1, onToggle: function () { return toggleGroupExpanded({ groupKey: params.tableRow.row.compoundKey }); } }), content)); }));
                    }
                    if (dxGridCore.isGroupIndentTableCell(params.tableRow, params.tableColumn, grouping)) {
                        if (GroupIndentCell) {
                            return (React.createElement(GroupIndentCell, __assign({}, params, { row: params.tableRow.row, column: params.tableColumn.column })));
                        }
                        return React.createElement(dxReactCore.TemplatePlaceholder, null);
                    }
                    return null;
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return dxGridCore.isGroupTableRow(tableRow);
                    } }, function (params) { return (React.createElement(GroupRow, __assign({}, params, { row: params.tableRow.row }))); })));
        };
        TableGroupRowBase.ROW_TYPE = dxGridCore.TABLE_GROUP_TYPE;
        TableGroupRowBase.COLUMN_TYPE = dxGridCore.TABLE_GROUP_TYPE;
        TableGroupRowBase.defaultProps = {
            showColumnsWhenGrouped: false,
        };
        TableGroupRowBase.components = {
            rowComponent: 'Row',
            cellComponent: 'Cell',
            contentComponent: 'Content',
            iconComponent: 'Icon',
        };
        return TableGroupRowBase;
    }(React.PureComponent));
    /** A plugin that renders group rows and enables them to expand and collapse. */
    var TableGroupRow = TableGroupRowBase;

    var tableHeaderRowsComputed$1 = function (_a) {
        var tableHeaderRows = _a.tableHeaderRows;
        return dxGridCore.tableRowsWithHeading(tableHeaderRows || []);
    };
    var TableHeaderRowBase = /*#__PURE__*/ (function (_super) {
        __extends(TableHeaderRowBase, _super);
        function TableHeaderRowBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableHeaderRowBase.prototype.render = function () {
            var _a = this.props, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, HeaderCell = _a.cellComponent, HeaderRow = _a.rowComponent, Content = _a.contentComponent, SortLabel = _a.sortLabelComponent, GroupButton = _a.groupButtonComponent, Title = _a.titleComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(messages);
            return (React.createElement(dxReactCore.Plugin, { name: "TableHeaderRow", dependencies: [
                    { name: 'Table' },
                    { name: 'SortingState', optional: !showSortingControls },
                    { name: 'GroupingState', optional: !showGroupingControls },
                    { name: 'DragDropProvider', optional: true },
                    { name: 'TableColumnResizing', optional: true },
                ] },
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$1 }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isHeadingTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var sorting = _a.sorting, tableColumns = _a.tableColumns, draggingEnabled = _a.draggingEnabled, tableColumnResizingEnabled = _a.tableColumnResizingEnabled, isColumnSortingEnabled = _a.isColumnSortingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                    var changeColumnSorting = _b.changeColumnSorting, changeColumnGrouping = _b.changeColumnGrouping, changeTableColumnWidth = _b.changeTableColumnWidth, draftTableColumnWidth = _b.draftTableColumnWidth, cancelTableColumnWidthDraft = _b.cancelTableColumnWidthDraft;
                    var _c = params.tableColumn.column, columnName = _c.name, columnTitle = _c.title;
                    var atLeastOneDataColumn = tableColumns
                        .filter(function (_a) {
                        var type = _a.type;
                        return type === dxGridCore.TABLE_DATA_TYPE;
                    }).length > 1;
                    var sortingEnabled = isColumnSortingEnabled
                        && isColumnSortingEnabled(columnName);
                    var groupingEnabled = isColumnGroupingEnabled
                        && isColumnGroupingEnabled(columnName)
                        && atLeastOneDataColumn;
                    return (React.createElement(HeaderCell, __assign({}, params, { column: params.tableColumn.column, draggingEnabled: draggingEnabled && atLeastOneDataColumn, resizingEnabled: tableColumnResizingEnabled, onWidthChange: function (_a) {
                            var shift = _a.shift;
                            return changeTableColumnWidth({ columnName: columnName, shift: shift });
                        }, onWidthDraft: function (_a) {
                            var shift = _a.shift;
                            return draftTableColumnWidth({ columnName: columnName, shift: shift });
                        }, onWidthDraftCancel: function () { return cancelTableColumnWidthDraft(); }, 
                        // @deprecated
                        sortingEnabled: sortingEnabled, 
                        // @deprecated
                        groupingEnabled: groupingEnabled, 
                        // @deprecated
                        showSortingControls: showSortingControls, 
                        // @deprecated
                        showGroupingControls: showGroupingControls, 
                        // @deprecated
                        sortingDirection: showSortingControls && sorting !== undefined
                            ? dxGridCore.getColumnSortingDirection(sorting, columnName) : undefined, 
                        // @deprecated
                        onSort: function (_a) {
                            var direction = _a.direction, keepOther = _a.keepOther;
                            return changeColumnSorting({
                                columnName: columnName, direction: direction, keepOther: keepOther,
                            });
                        }, 
                        // @deprecated
                        onGroup: function () { return changeColumnGrouping({ columnName: columnName }); }, 
                        // @deprecated
                        before: (React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableHeaderCellBefore", params: {
                                column: params.tableColumn.column,
                            } })) }),
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableHeaderCellBefore", params: {
                                column: params.tableColumn.column,
                            } }),
                        React.createElement(Content, { column: params.tableColumn.column, align: params.tableColumn.align }, showSortingControls ? (React.createElement(SortLabel, { column: params.tableColumn.column, align: params.tableColumn.align, direction: dxGridCore.getColumnSortingDirection(sorting, columnName) || null, disabled: !sortingEnabled, onSort: function (_a) {
                                var direction = _a.direction, keepOther = _a.keepOther;
                                changeColumnSorting({ columnName: columnName, direction: direction, keepOther: keepOther });
                            }, getMessage: getMessage },
                            React.createElement(Title, null, columnTitle || columnName))) : (React.createElement(Title, null, columnTitle || columnName))),
                        showGroupingControls ? (React.createElement(GroupButton, { disabled: !groupingEnabled, onGroup: function () { return changeColumnGrouping({ columnName: columnName }); } })) : null));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isHeadingTableRow(tableRow);
                    } }, function (params) { return React.createElement(HeaderRow, __assign({}, params)); })));
        };
        TableHeaderRowBase.ROW_TYPE = dxGridCore.TABLE_HEADING_TYPE;
        TableHeaderRowBase.defaultProps = {
            showSortingControls: false,
            showGroupingControls: false,
            messages: {},
        };
        TableHeaderRowBase.components = {
            cellComponent: 'Cell',
            rowComponent: 'Row',
            contentComponent: 'Content',
            sortLabelComponent: 'SortLabel',
            titleComponent: 'Title',
            groupButtonComponent: 'GroupButton',
        };
        return TableHeaderRowBase;
    }(React.PureComponent));
    TableHeaderRowBase.components = {
        cellComponent: 'Cell',
        rowComponent: 'Row',
        contentComponent: 'Content',
        sortLabelComponent: 'SortLabel',
        titleComponent: 'Title',
        groupButtonComponent: 'GroupButton',
    };
    /***
     * A plugin that renders the table's header row. The Column's `title` field specifies the
     * column's title in the header row.The plugin also allows you to manage a column's sorting
     * and grouping state and initiate column dragging.
     * */
    var TableHeaderRow = TableHeaderRowBase;

    var CellPlaceholder$1 = function (props) { return React.createElement(dxReactCore.TemplatePlaceholder, { params: props }); };
    var TableBandHeaderBase = /*#__PURE__*/ (function (_super) {
        __extends(TableBandHeaderBase, _super);
        function TableBandHeaderBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableBandHeaderBase.prototype.render = function () {
            var _a = this.props, Cell = _a.cellComponent, Row = _a.rowComponent, HeaderCell = _a.bandedHeaderCellComponent, InvisibleCell = _a.invisibleCellComponent, columnBands = _a.columnBands;
            var tableHeaderRowsComputed = function (_a) {
                var tableHeaderRows = _a.tableHeaderRows, tableColumns = _a.tableColumns;
                return dxGridCore.tableRowsWithBands(tableHeaderRows, columnBands, tableColumns);
            };
            var tableHeaderColumnChainsComputed = function (_a) {
                var tableHeaderRows = _a.tableHeaderRows, tableColumns = _a.tableColumns;
                return dxGridCore.tableHeaderColumnChainsWithBands(tableHeaderRows, tableColumns, columnBands);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableBandHeader", dependencies: [
                    { name: 'Table' },
                    { name: 'TableHeaderRow' },
                    { name: 'TableSelection', optional: true },
                    { name: 'TableEditColumn', optional: true },
                ] },
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isBandedOrHeaderRow(tableRow);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns, tableHeaderRows = _a.tableHeaderRows, tableHeaderColumnChains = _a.tableHeaderColumnChains;
                    var bandComponent = dxGridCore.getBandComponent(params, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains);
                    switch (bandComponent.type) {
                        case dxGridCore.BAND_DUPLICATE_RENDER:
                            return React.createElement(dxReactCore.TemplatePlaceholder, null);
                        case dxGridCore.BAND_EMPTY_CELL:
                            return React.createElement(InvisibleCell, null);
                        case dxGridCore.BAND_GROUP_CELL: {
                            var _b = bandComponent.payload, value = _b.value, payload = __rest(_b, ["value"]);
                            return (React.createElement(Cell, __assign({}, params, payload), value));
                        }
                        case dxGridCore.BAND_HEADER_CELL:
                            return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "tableCell", params: __assign({}, params, bandComponent.payload) }));
                        default:
                            return null;
                    }
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isHeadingTableCell(tableRow, tableColumn);
                    } }, function (params) { return React.createElement(HeaderCell, __assign({ component: CellPlaceholder$1 }, params)); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isBandedTableRow(tableRow);
                    } }, function (params) { return React.createElement(Row, __assign({}, params)); })));
        };
        TableBandHeaderBase.ROW_TYPE = dxGridCore.TABLE_BAND_TYPE;
        TableBandHeaderBase.components = {
            cellComponent: 'Cell',
            rowComponent: 'Row',
            bandedHeaderCellComponent: 'BandedHeaderCell',
            invisibleCellComponent: 'InvisibleCell',
        };
        return TableBandHeaderBase;
    }(React.PureComponent));
    TableBandHeaderBase.components = {
        cellComponent: 'Cell',
        rowComponent: 'Row',
        bandedHeaderCellComponent: 'BandedHeaderCell',
        invisibleCellComponent: 'InvisibleCell',
    };
    /** A plugin that renders the banded cells. */
    var TableBandHeader = TableBandHeaderBase;

    var pluginDependencies$b = [
        { name: 'FilteringState' },
        { name: 'Table' },
        { name: 'DataTypeProvider', optional: true },
    ];
    var defaultMessages$1 = {
        filterPlaceholder: 'Filter...',
        contains: 'Contains',
        notContains: 'Does not contain',
        startsWith: 'Starts with',
        endsWith: 'Ends with',
        equal: 'Equals',
        notEqual: 'Does not equal',
        greaterThan: 'Greater than',
        greaterThanOrEqual: 'Greater than or equal to',
        lessThan: 'Less than',
        lessThanOrEqual: 'Less than or equal to',
    };
    var TableFilterRowBase = /*#__PURE__*/ (function (_super) {
        __extends(TableFilterRowBase, _super);
        function TableFilterRowBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                filterOperations: {},
            };
            return _this;
        }
        TableFilterRowBase.prototype.render = function () {
            var _this = this;
            var _a = this.props, rowHeight = _a.rowHeight, showFilterSelector = _a.showFilterSelector, FilterCell = _a.cellComponent, FilterRow = _a.rowComponent, FilterSelector = _a.filterSelectorComponent, iconComponent = _a.iconComponent, toggleButtonComponent = _a.toggleButtonComponent, EditorComponent = _a.editorComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$1, messages));
            var tableHeaderRowsComputed = function (_a) {
                var tableHeaderRows = _a.tableHeaderRows;
                return dxGridCore.tableHeaderRowsWithFilter(tableHeaderRows, rowHeight);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableFilterRow", dependencies: pluginDependencies$b },
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isFilterTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var filters = _a.filters, isColumnFilteringEnabled = _a.isColumnFilteringEnabled, getAvailableFilterOperations = _a.getAvailableFilterOperations;
                    var changeColumnFilter = _b.changeColumnFilter;
                    var filterOperations = _this.state.filterOperations;
                    var columnName = params.tableColumn.column.name;
                    var filter = dxGridCore.getColumnFilterConfig(filters, columnName);
                    var onFilter = function (config) { return changeColumnFilter({ columnName: columnName, config: config }); };
                    var columnFilterOperations = dxGridCore.getColumnFilterOperations(getAvailableFilterOperations, columnName);
                    var selectedFilterOperation = dxGridCore.getSelectedFilterOperation(filterOperations, columnName, filter, columnFilterOperations);
                    var handleFilterOperationChange = function (value) {
                        var _a;
                        _this.setState({
                            filterOperations: __assign({}, filterOperations, (_a = {}, _a[columnName] = value, _a)),
                        });
                        if (filter && !dxGridCore.isFilterValueEmpty(filter.value)) {
                            onFilter({ value: filter.value, operation: value });
                        }
                    };
                    var handleFilterValueChange = function (value) { return onFilter(!dxGridCore.isFilterValueEmpty(value)
                        ? { value: value, operation: selectedFilterOperation }
                        : null); };
                    var filteringEnabled = isColumnFilteringEnabled(columnName);
                    return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "valueEditor", params: {
                            column: params.tableColumn.column,
                            value: filter ? filter.value : undefined,
                            onValueChange: handleFilterValueChange,
                        } }, function (content) { return (React.createElement(FilterCell, __assign({}, params, { getMessage: getMessage, column: params.tableColumn.column, filter: filter, filteringEnabled: filteringEnabled, onFilter: onFilter }),
                        showFilterSelector
                            ? (React.createElement(FilterSelector, { toggleButtonComponent: toggleButtonComponent, iconComponent: iconComponent, value: selectedFilterOperation, availableValues: columnFilterOperations, onChange: handleFilterOperationChange, disabled: !filteringEnabled, getMessage: getMessage })) : null,
                        content || (React.createElement(EditorComponent, { value: filter ? filter.value : undefined, disabled: !filteringEnabled, getMessage: getMessage, onChange: handleFilterValueChange })))); }));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isFilterTableRow(tableRow);
                    } }, function (params) { return React.createElement(FilterRow, __assign({}, params)); })));
        };
        TableFilterRowBase.ROW_TYPE = dxGridCore.TABLE_FILTER_TYPE;
        TableFilterRowBase.defaultProps = {
            showFilterSelector: false,
            messages: {},
        };
        TableFilterRowBase.components = {
            rowComponent: 'Row',
            cellComponent: 'Cell',
            filterSelectorComponent: 'FilterSelector',
            iconComponent: 'Icon',
            editorComponent: 'Editor',
            toggleButtonComponent: 'ToggleButton',
        };
        return TableFilterRowBase;
    }(React.PureComponent));
    /** A plugin that renders a filter row. */
    var TableFilterRow = TableFilterRowBase;

    var pluginDependencies$c = [
        { name: 'EditingState' },
        { name: 'Table' },
        { name: 'DataTypeProvider', optional: true },
    ];
    var TableEditRowBase = /*#__PURE__*/ (function (_super) {
        __extends(TableEditRowBase, _super);
        function TableEditRowBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableEditRowBase.prototype.render = function () {
            var _a = this.props, EditCell = _a.cellComponent, EditRow = _a.rowComponent, rowHeight = _a.rowHeight;
            var tableBodyRowsComputed = function (_a) {
                var tableBodyRows = _a.tableBodyRows, editingRowIds = _a.editingRowIds, addedRows = _a.addedRows;
                return dxGridCore.tableRowsWithEditing(tableBodyRows, editingRowIds, addedRows, rowHeight);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableEditRow", dependencies: pluginDependencies$c },
                React.createElement(dxReactCore.Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isEditTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var getCellValue = _a.getCellValue, createRowChange = _a.createRowChange, rowChanges = _a.rowChanges, isColumnEditingEnabled = _a.isColumnEditingEnabled;
                    var changeAddedRow = _b.changeAddedRow, changeRow = _b.changeRow;
                    var _c = params.tableRow, rowId = _c.rowId, row = _c.row;
                    var column = params.tableColumn.column;
                    var columnName = column.name;
                    var isNew = dxGridCore.isAddedTableRow(params.tableRow);
                    var changedRow = isNew
                        ? row
                        : __assign({}, row, dxGridCore.getRowChange(rowChanges, rowId));
                    var value = getCellValue(changedRow, columnName);
                    var onValueChange = function (newValue) {
                        var changeArgs = {
                            rowId: rowId,
                            change: createRowChange(changedRow, newValue, columnName),
                        };
                        if (isNew) {
                            changeAddedRow(changeArgs);
                        }
                        else {
                            changeRow(changeArgs);
                        }
                    };
                    return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "valueEditor", params: {
                            column: column,
                            row: row,
                            value: value,
                            onValueChange: onValueChange,
                        } }, function (content) { return (React.createElement(EditCell, __assign({}, params, { row: row, column: column, value: value, editingEnabled: isColumnEditingEnabled(columnName), onValueChange: onValueChange }), content)); }));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!(dxGridCore.isEditTableRow(tableRow) || dxGridCore.isAddedTableRow(tableRow));
                    } }, function (params) { return (React.createElement(EditRow, __assign({}, params, { row: params.tableRow.row }))); })));
        };
        TableEditRowBase.ADDED_ROW_TYPE = dxGridCore.TABLE_ADDED_TYPE;
        TableEditRowBase.EDIT_ROW_TYPE = dxGridCore.TABLE_EDIT_TYPE;
        TableEditRowBase.components = {
            rowComponent: 'Row',
            cellComponent: 'Cell',
        };
        return TableEditRowBase;
    }(React.PureComponent));
    /** A plugin that renders a row being edited. */
    var TableEditRow = TableEditRowBase;

    var pluginDependencies$d = [
        { name: 'EditingState' },
        { name: 'Table' },
    ];
    var defaultMessages$2 = {
        addCommand: 'New',
        editCommand: 'Edit',
        deleteCommand: 'Delete',
        commitCommand: 'Save',
        cancelCommand: 'Cancel',
    };
    var TableEditColumnBase = /*#__PURE__*/ (function (_super) {
        __extends(TableEditColumnBase, _super);
        function TableEditColumnBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableEditColumnBase.prototype.render = function () {
            var _a = this.props, Cell = _a.cellComponent, HeaderCell = _a.headerCellComponent, Command = _a.commandComponent, showAddCommand = _a.showAddCommand, showEditCommand = _a.showEditCommand, showDeleteCommand = _a.showDeleteCommand, width = _a.width, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$2, messages));
            var tableColumnsComputed = function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithEditing(tableColumns, width);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableEditColumn", dependencies: pluginDependencies$d },
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isHeadingEditCommandsTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (getters, actions) { return (React.createElement(HeaderCell, __assign({}, params), showAddCommand && (React.createElement(Command, { id: "add", text: getMessage('addCommand'), onExecute: function () { return actions.addRow(); } })))); })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isEditCommandsTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (getters, actions) {
                    var isEdit = dxGridCore.isEditTableRow(params.tableRow);
                    var isNew = dxGridCore.isAddedTableRow(params.tableRow);
                    var isEditing = isEdit || isNew;
                    var rowIds = [params.tableRow.rowId];
                    return (React.createElement(Cell, __assign({}, params, { row: params.tableRow.row }),
                        showEditCommand && !isEditing && (React.createElement(Command, { id: "edit", text: getMessage('editCommand'), onExecute: function () { return actions.startEditRows({ rowIds: rowIds }); } })),
                        showDeleteCommand && !isEditing && (React.createElement(Command, { id: "delete", text: getMessage('deleteCommand'), onExecute: function () {
                                actions.deleteRows({ rowIds: rowIds });
                                actions.commitDeletedRows({ rowIds: rowIds });
                            } })),
                        isEditing && (React.createElement(Command, { id: "commit", text: getMessage('commitCommand'), onExecute: function () {
                                if (isNew) {
                                    actions.commitAddedRows({ rowIds: rowIds });
                                }
                                else {
                                    actions.stopEditRows({ rowIds: rowIds });
                                    actions.commitChangedRows({ rowIds: rowIds });
                                }
                            } })),
                        isEditing && (React.createElement(Command, { id: "cancel", text: getMessage('cancelCommand'), onExecute: function () {
                                if (isNew) {
                                    actions.cancelAddedRows({ rowIds: rowIds });
                                }
                                else {
                                    actions.stopEditRows({ rowIds: rowIds });
                                    actions.cancelChangedRows({ rowIds: rowIds });
                                }
                            } }))));
                })); })));
        };
        TableEditColumnBase.COLUMN_TYPE = dxGridCore.TABLE_EDIT_COMMAND_TYPE;
        TableEditColumnBase.defaultProps = {
            showAddCommand: false,
            showEditCommand: false,
            showDeleteCommand: false,
            width: 140,
            messages: {},
        };
        TableEditColumnBase.components = {
            cellComponent: 'Cell',
            headerCellComponent: 'HeaderCell',
            commandComponent: 'Command',
        };
        return TableEditColumnBase;
    }(React.PureComponent));
    /***
     * A plugin that renders a command column. This column contains controls used for row editing,
     * creating, or deleting and committing/canceling changes.
     * */
    var TableEditColumn = TableEditColumnBase;

    var pluginDependencies$e = [
        { name: 'Table' },
    ];
    // tslint:disable-next-line: max-line-length
    var TableColumnResizingBase = /*#__PURE__*/ (function (_super) {
        __extends(TableColumnResizingBase, _super);
        function TableColumnResizingBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                columnWidths: props.columnWidths || props.defaultColumnWidths,
                draftColumnWidths: [],
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                columnWidths: function () {
                    var onColumnWidthsChange = _this.props.onColumnWidthsChange;
                    return onColumnWidthsChange;
                },
            });
            _this.tableColumnsComputed = dxCore.memoize(function (columnWidths) { return function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithWidths(tableColumns, columnWidths);
            }; });
            _this.tableColumnsDraftComputed = dxCore.memoize(function (draftColumnWidths) { return function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithDraftWidths(tableColumns, draftColumnWidths);
            }; });
            _this.changeTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
                var minColumnWidth = _this.props.minColumnWidth;
                return dxGridCore.changeTableColumnWidth(prevState, __assign({}, payload, { minColumnWidth: minColumnWidth }));
            });
            _this.draftTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function (prevState, payload) {
                var minColumnWidth = _this.props.minColumnWidth;
                return dxGridCore.draftTableColumnWidth(prevState, __assign({}, payload, { minColumnWidth: minColumnWidth }));
            });
            _this.cancelTableColumnWidthDraft = stateHelper.applyReducer.bind(stateHelper, dxGridCore.cancelTableColumnWidthDraft);
            return _this;
        }
        TableColumnResizingBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.columnWidths, columnWidths = _a === void 0 ? prevState.columnWidths : _a;
            return {
                columnWidths: columnWidths,
            };
        };
        TableColumnResizingBase.prototype.render = function () {
            var _a = this.state, columnWidths = _a.columnWidths, draftColumnWidths = _a.draftColumnWidths;
            var tableColumnsComputed = this.tableColumnsComputed(columnWidths);
            var tableColumnsDraftComputed = this.tableColumnsDraftComputed(draftColumnWidths);
            return (React.createElement(dxReactCore.Plugin, { name: "TableColumnResizing", dependencies: pluginDependencies$e },
                React.createElement(dxReactCore.Getter, { name: "tableColumnResizingEnabled", value: true }),
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsDraftComputed }),
                React.createElement(dxReactCore.Action, { name: "changeTableColumnWidth", action: this.changeTableColumnWidth }),
                React.createElement(dxReactCore.Action, { name: "draftTableColumnWidth", action: this.draftTableColumnWidth }),
                React.createElement(dxReactCore.Action, { name: "cancelTableColumnWidthDraft", action: this.cancelTableColumnWidthDraft })));
        };
        TableColumnResizingBase.defaultProps = {
            defaultColumnWidths: [],
        };
        return TableColumnResizingBase;
    }(React.PureComponent));
    /* tslint:disable: max-line-length */
    /** A plugin that manages table column widths. */
    var TableColumnResizing = TableColumnResizingBase;
    /* tslint:enable: max-line-length */

    var pluginDependencies$f = [
        { name: 'PagingState' },
    ];
    var defaultMessages$3 = {
        showAll: 'All',
        info: function (_a) {
            var from = _a.from, to = _a.to, count = _a.count;
            return "" + from + (from < to ? "-" + to : '') + " of " + count;
        },
    };
    var PagingPanelBase = /*#__PURE__*/ (function (_super) {
        __extends(PagingPanelBase, _super);
        function PagingPanelBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        PagingPanelBase.prototype.render = function () {
            var _a = this.props, Pager = _a.containerComponent, pageSizes = _a.pageSizes, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$3, messages));
            return (React.createElement(dxReactCore.Plugin, { name: "PagingPanel", dependencies: pluginDependencies$f },
                React.createElement(dxReactCore.Template, { name: "footer" },
                    React.createElement(dxReactCore.TemplatePlaceholder, null),
                    React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                        var currentPage = _a.currentPage, pageSize = _a.pageSize, totalCount = _a.totalCount;
                        var setCurrentPage = _b.setCurrentPage, setPageSize = _b.setPageSize;
                        return (React.createElement(Pager, { currentPage: currentPage, pageSize: pageSize, totalCount: totalCount, totalPages: dxGridCore.pageCount(totalCount, pageSize), pageSizes: pageSizes, getMessage: getMessage, onCurrentPageChange: setCurrentPage, onPageSizeChange: setPageSize }));
                    }))));
        };
        PagingPanelBase.defaultProps = {
            pageSizes: [],
            messages: {},
        };
        PagingPanelBase.components = {
            containerComponent: 'Container',
        };
        return PagingPanelBase;
    }(React.PureComponent));
    /** A plugin that renders the paging panel used for navigation through data pages. */
    var PagingPanel = PagingPanelBase;

    var defaultProps = {
        draggingEnabled: false,
        onDragStart: function () { },
        onDragEnd: function () { },
    };
    // tslint:disable-next-line: max-line-length
    var ItemLayout = /*#__PURE__*/ (function (_super) {
        __extends(ItemLayout, _super);
        function ItemLayout(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                dragging: false,
            };
            return _this;
        }
        ItemLayout.prototype.render = function () {
            var _this = this;
            var _a = this.props, item = _a.item, Item = _a.itemComponent, draggingEnabled = _a.draggingEnabled, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd;
            var dragging = this.state.dragging;
            var itemElement = React.createElement(Item, { item: __assign({}, item, { draft: dragging || item.draft }) });
            return (draggingEnabled ? (React.createElement(dxReactCore.DragSource, { payload: [{ type: 'column', columnName: item.column.name }], onStart: function () {
                    _this.setState({ dragging: true });
                    onDragStart();
                }, onEnd: function () {
                    _this.setState({ dragging: false });
                    onDragEnd();
                } }, itemElement)) : (itemElement));
        };
        ItemLayout.defaultProps = defaultProps;
        return ItemLayout;
    }(React.PureComponent));

    var defaultProps$1 = {
        onGroup: function () { },
        draggingEnabled: false,
        isColumnGroupingEnabled: function () { return false; },
        onGroupDraft: function () { },
        onGroupDraftCancel: function () { },
    };
    // tslint:disable-next-line: max-line-length
    var GroupPanelLayoutBase = /*#__PURE__*/ (function (_super) {
        __extends(GroupPanelLayoutBase, _super);
        function GroupPanelLayoutBase(props) {
            var _this = _super.call(this, props) || this;
            _this.itemRefs = [];
            _this.draggingColumnName = null;
            _this.state = {
                sourceColumnName: null,
                targetItemIndex: -1,
            };
            _this.handleDragEvent = function (eventHandler, _a) {
                var payload = _a.payload, restArgs = __rest(_a, ["payload"]);
                var isColumnGroupingEnabled = _this.props.isColumnGroupingEnabled;
                var columnName = payload[0].columnName;
                if (isColumnGroupingEnabled(columnName)) {
                    eventHandler(__assign({ payload: payload }, restArgs));
                }
            };
            _this.onEnter = function (_a) {
                var payload = _a.payload;
                _this.setState({
                    sourceColumnName: payload[0].columnName,
                });
            };
            _this.onOver = function (_a) {
                var clientOffset = _a.clientOffset;
                var _b = _this.props, onGroupDraft = _b.onGroupDraft, items = _b.items;
                var _c = _this.state, sourceColumnName = _c.sourceColumnName, prevTargetItemIndex = _c.targetItemIndex;
                // eslint-disable-next-line react/no-find-dom-node
                var itemGeometries = _this.itemRefs
                    .map(function (ref) { return reactDom.findDOMNode(ref).getBoundingClientRect(); });
                var sourceItemIndex = items.findIndex(function (_a) {
                    var column = _a.column;
                    return column.name === sourceColumnName;
                });
                var targetItemIndex = dxGridCore.getGroupCellTargetIndex(itemGeometries, sourceItemIndex, clientOffset);
                if (prevTargetItemIndex === targetItemIndex)
                    return;
                onGroupDraft({
                    columnName: sourceColumnName,
                    groupIndex: targetItemIndex,
                });
                _this.setState({ targetItemIndex: targetItemIndex });
            };
            _this.onLeave = function () {
                var onGroupDraft = _this.props.onGroupDraft;
                var sourceColumnName = _this.state.sourceColumnName;
                if (!_this.draggingColumnName) {
                    _this.resetState();
                    return;
                }
                onGroupDraft({
                    columnName: sourceColumnName,
                    groupIndex: -1,
                });
                _this.setState({
                    targetItemIndex: -1,
                });
            };
            _this.onDrop = function () {
                var onGroup = _this.props.onGroup;
                var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
                _this.resetState();
                onGroup({
                    columnName: sourceColumnName,
                    groupIndex: targetItemIndex,
                });
            };
            _this.onDragStart = function (columnName) {
                _this.draggingColumnName = columnName;
            };
            _this.onDragEnd = function () {
                _this.draggingColumnName = null;
                var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
                var onGroup = _this.props.onGroup;
                if (sourceColumnName && targetItemIndex === -1) {
                    onGroup({
                        columnName: sourceColumnName,
                    });
                }
                _this.resetState();
            };
            return _this;
        }
        GroupPanelLayoutBase.prototype.resetState = function () {
            var onGroupDraftCancel = this.props.onGroupDraftCancel;
            onGroupDraftCancel();
            this.setState({
                sourceColumnName: null,
                targetItemIndex: -1,
            });
        };
        GroupPanelLayoutBase.prototype.render = function () {
            var _this = this;
            var _a = this.props, items = _a.items, EmptyMessage = _a.emptyMessageComponent, Container = _a.containerComponent, Item = _a.itemComponent, draggingEnabled = _a.draggingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
            this.itemRefs = [];
            var groupPanel = (items.length ? (React.createElement(Container, null, items.map(function (item) {
                var columnName = item.column.name;
                return (React.createElement(ItemLayout, { key: columnName, ref: function (element) { return element && _this.itemRefs.push(element); }, item: item, itemComponent: Item, draggingEnabled: draggingEnabled && isColumnGroupingEnabled(columnName), onDragStart: function () { return _this.onDragStart(columnName); }, onDragEnd: _this.onDragEnd }));
            }))) : (React.createElement(EmptyMessage, null)));
            return draggingEnabled
                ? (React.createElement(dxReactCore.DropTarget, { onEnter: function (args) { return _this.handleDragEvent(_this.onEnter, args); }, onOver: function (args) { return _this.handleDragEvent(_this.onOver, args); }, onLeave: function (args) { return _this.handleDragEvent(_this.onLeave, args); }, onDrop: function (args) { return _this.handleDragEvent(_this.onDrop, args); } }, groupPanel))
                : groupPanel;
        };
        GroupPanelLayoutBase.defaultProps = defaultProps$1;
        return GroupPanelLayoutBase;
    }(React.PureComponent));
    /** @internal */
    var GroupPanelLayout = GroupPanelLayoutBase;

    var defaultMessages$4 = {
        groupByColumn: 'Drag a column header here to group by that column',
    };
    var defaultProps$2 = {
        showSortingControls: false,
        showGroupingControls: false,
        messages: {},
    };
    var GroupingPanelRaw = /*#__PURE__*/ (function (_super) {
        __extends(GroupingPanelRaw, _super);
        function GroupingPanelRaw() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        GroupingPanelRaw.prototype.render = function () {
            var _a = this.props, LayoutComponent = _a.layoutComponent, Container = _a.containerComponent, Item = _a.itemComponent, EmptyMessage = _a.emptyMessageComponent, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$4, messages));
            var EmptyMessagePlaceholder = function () { return (React.createElement(EmptyMessage, { getMessage: getMessage })); };
            var ItemPlaceholder = function (_a) {
                var item = _a.item;
                var columnName = item.column.name;
                return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var sorting = _a.sorting, isColumnSortingEnabled = _a.isColumnSortingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                    var changeColumnGrouping = _b.changeColumnGrouping, changeColumnSorting = _b.changeColumnSorting;
                    var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
                    var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName);
                    return (React.createElement(Item, { item: item, sortingEnabled: sortingEnabled, groupingEnabled: groupingEnabled, showSortingControls: showSortingControls, sortingDirection: showSortingControls
                            ? dxGridCore.getColumnSortingDirection(sorting, columnName) : undefined, showGroupingControls: showGroupingControls, onGroup: function () { return changeColumnGrouping({ columnName: columnName }); }, onSort: function (_a) {
                            var direction = _a.direction, keepOther = _a.keepOther;
                            return changeColumnSorting({ columnName: columnName, direction: direction, keepOther: keepOther });
                        } }));
                }));
            };
            return (React.createElement(dxReactCore.Plugin, { name: "GroupingPanel", dependencies: [
                    { name: 'GroupingState' },
                    { name: 'Toolbar' },
                    { name: 'SortingState', optional: !showSortingControls },
                ] },
                React.createElement(dxReactCore.Template, { name: "toolbarContent" },
                    React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                        var columns = _a.columns, grouping = _a.grouping, draftGrouping = _a.draftGrouping, draggingEnabled = _a.draggingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
                        var changeColumnGrouping = _b.changeColumnGrouping, draftColumnGrouping = _b.draftColumnGrouping, cancelColumnGroupingDraft = _b.cancelColumnGroupingDraft;
                        return (React.createElement(LayoutComponent, { items: dxGridCore.groupingPanelItems(columns, grouping, draftGrouping), isColumnGroupingEnabled: isColumnGroupingEnabled, draggingEnabled: draggingEnabled, onGroup: changeColumnGrouping, onGroupDraft: draftColumnGrouping, onGroupDraftCancel: cancelColumnGroupingDraft, itemComponent: ItemPlaceholder, emptyMessageComponent: EmptyMessagePlaceholder, containerComponent: Container }));
                    }),
                    React.createElement(dxReactCore.TemplatePlaceholder, null))));
        };
        GroupingPanelRaw.defaultProps = defaultProps$2;
        GroupingPanelRaw.components = {
            layoutComponent: 'Layout',
            containerComponent: 'Container',
            itemComponent: 'Item',
            emptyMessageComponent: 'EmptyMessage',
        };
        return GroupingPanelRaw;
    }(React.PureComponent));
    /***
     * A plugin that renders the Grouping Panel in the Grid's header. This panel displays grouped
     * columns and allows a user to modify grouping options.Optionally, the plugin allows an end-user
     * to change grouped columns' sorting order and render sorting indicators.
     * */
    var GroupingPanel = dxReactCore.withComponents({ Layout: GroupPanelLayout })(GroupingPanelRaw);

    var DataTypeProviderBase = /*#__PURE__*/ (function (_super) {
        __extends(DataTypeProviderBase, _super);
        function DataTypeProviderBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DataTypeProviderBase.prototype.render = function () {
            var _a = this.props, columnNames = _a.for, Formatter = _a.formatterComponent, Editor = _a.editorComponent, availableFilterOperations = _a.availableFilterOperations;
            var getAvailableFilterOperationsComputed = function (_a) {
                var getAvailableFilterOperations = _a.getAvailableFilterOperations;
                return dxGridCore.getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "DataTypeProvider" },
                React.createElement(dxReactCore.Getter, { name: "getAvailableFilterOperations", computed: getAvailableFilterOperationsComputed }),
                Formatter
                    ? (React.createElement(dxReactCore.Template, { name: "valueFormatter", predicate: function (_a) {
                            var column = _a.column;
                            return columnNames.includes(column.name);
                        } }, function (params) { return React.createElement(Formatter, __assign({}, params)); }))
                    : null,
                Editor
                    ? (React.createElement(dxReactCore.Template, { name: "valueEditor", predicate: function (_a) {
                            var column = _a.column;
                            return columnNames.includes(column.name);
                        } }, function (params) { return React.createElement(Editor, __assign({}, params)); }))
                    : null));
        };
        return DataTypeProviderBase;
    }(React.PureComponent));
    // tslint:disable-next-line: max-line-length
    /** A plugin that allows you to customize formatting options and editors depending on the data type. */
    var DataTypeProvider = DataTypeProviderBase;

    var pluginDependencies$g = [
        { name: 'Table' },
    ];
    var defaultMessages$5 = {
        noColumns: 'Nothing to show',
    };
    var visibleTableColumnsComputed = function (_a) {
        var tableColumns = _a.tableColumns, hiddenColumnNames = _a.hiddenColumnNames;
        return dxGridCore.visibleTableColumns(tableColumns, hiddenColumnNames);
    };
    var columnExtensionValueGetter$4 = function (columnExtensions, defaultValue) { return dxGridCore.getColumnExtensionValueGetter(columnExtensions, 'togglingEnabled', defaultValue); };
    // tslint:disable-next-line: max-line-length
    var TableColumnVisibilityBase = /*#__PURE__*/ (function (_super) {
        __extends(TableColumnVisibilityBase, _super);
        function TableColumnVisibilityBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                hiddenColumnNames: props.hiddenColumnNames || props.defaultHiddenColumnNames,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                hiddenColumnNames: function () {
                    var onHiddenColumnNamesChange = _this.props.onHiddenColumnNamesChange;
                    return onHiddenColumnNamesChange;
                },
            });
            _this.toggleColumnVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'hiddenColumnNames', dxGridCore.toggleColumn);
            return _this;
        }
        TableColumnVisibilityBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.hiddenColumnNames, hiddenColumnNames = _a === void 0 ? prevState.hiddenColumnNames : _a;
            return {
                hiddenColumnNames: hiddenColumnNames,
            };
        };
        TableColumnVisibilityBase.prototype.render = function () {
            var _a = this.props, EmptyMessage = _a.emptyMessageComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$5, messages));
            var hiddenColumnNames = this.state.hiddenColumnNames;
            var _b = this.props, columnExtensions = _b.columnExtensions, columnTogglingEnabled = _b.columnTogglingEnabled;
            return (React.createElement(dxReactCore.Plugin, { name: "TableColumnVisibility", dependencies: pluginDependencies$g },
                React.createElement(dxReactCore.Getter, { name: "hiddenColumnNames", value: hiddenColumnNames }),
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: visibleTableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "isColumnTogglingEnabled", value: columnExtensionValueGetter$4(columnExtensions, columnTogglingEnabled) }),
                React.createElement(dxReactCore.Action, { name: "toggleColumnVisibility", action: this.toggleColumnVisibility }),
                React.createElement(dxReactCore.Template, { name: "table" }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns;
                    return (dxGridCore.tableDataColumnsExist(tableColumns)
                        ? React.createElement(dxReactCore.TemplatePlaceholder, null)
                        : (React.createElement(EmptyMessage, __assign({ getMessage: getMessage }, params))));
                })); })));
        };
        TableColumnVisibilityBase.defaultProps = {
            defaultHiddenColumnNames: [],
            messages: {},
            columnTogglingEnabled: true,
        };
        TableColumnVisibilityBase.components = {
            emptyMessageComponent: 'EmptyMessage',
        };
        return TableColumnVisibilityBase;
    }(React.PureComponent));
    TableColumnVisibilityBase.components = {
        emptyMessageComponent: 'EmptyMessage',
    };
    /* tslint:disable: max-line-length */
    /** A plugin that manages Grid columns' visibility. */
    var TableColumnVisibility = TableColumnVisibilityBase;
    /* tslint:enable: max-line-length */

    var ToolbarBase = /*#__PURE__*/ (function (_super) {
        __extends(ToolbarBase, _super);
        function ToolbarBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ToolbarBase.prototype.render = function () {
            var _a = this.props, Root = _a.rootComponent, FlexibleSpaceComponent = _a.flexibleSpaceComponent;
            return (React.createElement(dxReactCore.Plugin, { name: "Toolbar" },
                React.createElement(dxReactCore.Template, { name: "header" },
                    React.createElement(Root, null,
                        React.createElement(dxReactCore.TemplatePlaceholder, { name: "toolbarContent" })),
                    React.createElement(dxReactCore.TemplatePlaceholder, null)),
                React.createElement(dxReactCore.Template, { name: "toolbarContent" },
                    React.createElement(FlexibleSpaceComponent, null))));
        };
        ToolbarBase.components = {
            rootComponent: 'Root',
            flexibleSpaceComponent: 'FlexibleSpace',
        };
        return ToolbarBase;
    }(React.PureComponent));
    /** A plugin that renders the Grid toolbar. */
    var Toolbar = ToolbarBase;

    var TreeDataStateBase = /*#__PURE__*/ (function (_super) {
        __extends(TreeDataStateBase, _super);
        function TreeDataStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                expandedRowIds: function () {
                    var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
                    return onExpandedRowIdsChange;
                },
            });
            _this.toggleRowExpanded = stateHelper.applyFieldReducer
                .bind(stateHelper, 'expandedRowIds', dxGridCore.toggleRowExpanded);
            return _this;
        }
        TreeDataStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
            return {
                expandedRowIds: expandedRowIds,
            };
        };
        TreeDataStateBase.prototype.render = function () {
            var expandedRowIds = this.state.expandedRowIds;
            return (React.createElement(dxReactCore.Plugin, { name: "TreeDataState" },
                React.createElement(dxReactCore.Getter, { name: "expandedRowIds", value: expandedRowIds }),
                ' ',
                React.createElement(dxReactCore.Action, { name: "toggleRowExpanded", action: this.toggleRowExpanded })));
        };
        TreeDataStateBase.defaultProps = {
            defaultExpandedRowIds: [],
        };
        return TreeDataStateBase;
    }(React.PureComponent));
    /** A plugin that manages the expanded state for tree rows. */
    var TreeDataState = TreeDataStateBase;

    var pluginDependencies$h = [
        { name: 'TreeDataState' },
    ];
    var expandedTreeRowsComputed = function (_a) {
        var rows = _a.rows, getRowId = _a.getRowId, expandedRowIds = _a.expandedRowIds;
        return dxGridCore.expandedTreeRows(rows, getRowId, expandedRowIds);
    };
    var getRowIdComputed$1 = function (_a) {
        var getRowId = _a.getRowId, rows = _a.rows;
        return dxGridCore.customTreeRowIdGetter(getRowId, rows);
    };
    var getRowLevelKeyComputed = function (_a) {
        var getRowLevelKey = _a.getRowLevelKey, rows = _a.rows;
        return dxGridCore.customTreeRowLevelKeyGetter(getRowLevelKey, rows);
    };
    var isTreeRowLeafComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.isTreeRowLeafGetter(rows);
    };
    var getTreeRowLevelComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.getTreeRowLevelGetter(rows);
    };
    var collapsedTreeRowsGetterComputed = function (_a) {
        var rows = _a.rows, getCollapsedRows = _a.getCollapsedRows;
        return dxGridCore.collapsedTreeRowsGetter(getCollapsedRows, rows);
    };
    var unwrappedTreeRowsComputed = function (_a) {
        var rows = _a.rows;
        return dxGridCore.unwrappedCustomTreeRows(rows);
    };
    var CustomTreeDataBase = /*#__PURE__*/ (function (_super) {
        __extends(CustomTreeDataBase, _super);
        function CustomTreeDataBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomTreeDataBase.prototype.render = function () {
            var getChildRows = this.props.getChildRows;
            var treeRowsComputed = function (_a) {
                var rows = _a.rows;
                return dxGridCore.customTreeRowsWithMeta(rows, getChildRows);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "CustomTreeData", dependencies: pluginDependencies$h },
                React.createElement(dxReactCore.Getter, { name: "rows", computed: treeRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getRowId", computed: getRowIdComputed$1 }),
                React.createElement(dxReactCore.Getter, { name: "getRowLevelKey", computed: getRowLevelKeyComputed }),
                React.createElement(dxReactCore.Getter, { name: "isTreeRowLeaf", computed: isTreeRowLeafComputed }),
                React.createElement(dxReactCore.Getter, { name: "getTreeRowLevel", computed: getTreeRowLevelComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: expandedTreeRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "getCollapsedRows", computed: collapsedTreeRowsGetterComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: unwrappedTreeRowsComputed })));
        };
        return CustomTreeDataBase;
    }(React.PureComponent));
    /***
     * A plugin that converts custom formatted tree data to a supported format and performs
     * local row expanding/collapsing.
     * */
    var CustomTreeData = CustomTreeDataBase;

    var TableTreeColumnBase = /*#__PURE__*/ (function (_super) {
        __extends(TableTreeColumnBase, _super);
        function TableTreeColumnBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableTreeColumnBase.prototype.render = function () {
            var _a = this.props, forColumnName = _a.for, showSelectionControls = _a.showSelectionControls, showSelectAll = _a.showSelectAll, Indent = _a.indentComponent, ExpandButton = _a.expandButtonComponent, Checkbox = _a.checkboxComponent, Content = _a.contentComponent, Cell = _a.cellComponent;
            return (React.createElement(dxReactCore.Plugin, { name: "TableTreeColumn", dependencies: [
                    { name: 'DataTypeProvider', optional: true },
                    { name: 'TreeDataState' },
                    { name: 'SelectionState', optional: !showSelectionControls },
                    { name: 'IntegratedSelection', optional: !showSelectAll },
                    { name: 'Table' },
                    { name: 'TableHeaderRow', optional: true },
                ] },
                React.createElement(dxReactCore.Getter, { name: "tableTreeColumnName", value: forColumnName }),
                React.createElement(dxReactCore.Template, { name: "tableHeaderCellBefore", predicate: function (_a) {
                        var column = _a.column;
                        return column.name === forColumnName;
                    } },
                    React.createElement(ExpandButton, { visible: false, expanded: false, onToggle: function () { } }),
                    showSelectionControls && showSelectAll && (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                        var selectAllAvailable = _a.selectAllAvailable, allSelected = _a.allSelected, someSelected = _a.someSelected;
                        var toggleSelectAll = _b.toggleSelectAll;
                        return (React.createElement(Checkbox, { disabled: !selectAllAvailable, checked: allSelected, indeterminate: someSelected, onChange: toggleSelectAll }));
                    }))),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isTreeTableCell(tableRow, tableColumn, forColumnName);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                    var getCollapsedRows = _a.getCollapsedRows, expandedRowIds = _a.expandedRowIds, selection = _a.selection, isTreeRowLeaf = _a.isTreeRowLeaf, getTreeRowLevel = _a.getTreeRowLevel, getCellValue = _a.getCellValue;
                    var toggleRowExpanded = _b.toggleRowExpanded, toggleSelection = _b.toggleSelection;
                    var _c = params.tableRow, row = _c.row, rowId = _c.rowId;
                    var columnName = params.tableColumn.column.name;
                    var value = getCellValue(row, columnName);
                    var collapsedRows = getCollapsedRows(row);
                    return (React.createElement(dxReactCore.TemplatePlaceholder, { name: "valueFormatter", params: {
                            value: value,
                            row: row,
                            column: params.tableColumn.column,
                        } }, function (content) { return (React.createElement(Cell, __assign({}, params, { row: row, column: params.tableColumn.column, value: value }),
                        React.createElement(Indent, { level: getTreeRowLevel(row) }),
                        React.createElement(ExpandButton, { visible: collapsedRows ? !!collapsedRows.length : !isTreeRowLeaf(row), expanded: expandedRowIds.indexOf(rowId) > -1, onToggle: function () { return toggleRowExpanded({ rowId: rowId }); } }),
                        showSelectionControls && (React.createElement(Checkbox, { disabled: false, checked: selection.indexOf(rowId) > -1, indeterminate: false, onChange: function () { return toggleSelection({ rowIds: [rowId] }); } })),
                        React.createElement(Content, null, content || value))); }));
                })); })));
        };
        TableTreeColumnBase.defaultProps = {
            showSelectionControls: false,
            showSelectAll: false,
        };
        TableTreeColumnBase.components = {
            cellComponent: 'Cell',
            contentComponent: 'Content',
            indentComponent: 'Indent',
            expandButtonComponent: 'ExpandButton',
            checkboxComponent: 'Checkbox',
        };
        return TableTreeColumnBase;
    }(React.PureComponent));
    /** A plugin that renders a table column with a toggle button and sorting indicators. */
    var TableTreeColumn = TableTreeColumnBase;

    var SearchStateBase = /*#__PURE__*/ (function (_super) {
        __extends(SearchStateBase, _super);
        function SearchStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                value: props.value || props.defaultValue,
            };
            var stateHelper = dxReactCore.createStateHelper(_this, {
                value: function () {
                    var onValueChange = _this.props.onValueChange;
                    return onValueChange;
                },
            });
            _this.changeValue = stateHelper.applyFieldReducer
                .bind(stateHelper, 'value', dxGridCore.changeSearchValue);
            return _this;
        }
        SearchStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.value, value = _a === void 0 ? prevState.value : _a;
            return {
                value: value,
            };
        };
        SearchStateBase.prototype.render = function () {
            var value = this.state.value;
            var filterExpressionComputed = function (_a) {
                var filterExpression = _a.filterExpression, columns = _a.columns;
                return dxGridCore.searchFilterExpression(value, columns, filterExpression);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "SearchState" },
                React.createElement(dxReactCore.Getter, { name: "filterExpression", computed: filterExpressionComputed }),
                React.createElement(dxReactCore.Getter, { name: "searchValue", value: value }),
                React.createElement(dxReactCore.Action, { name: "changeSearchValue", action: this.changeValue })));
        };
        SearchStateBase.defaultProps = {
            defaultValue: '',
        };
        return SearchStateBase;
    }(React.PureComponent));
    /** A plugin that manages the search state. */
    var SearchState = SearchStateBase;

    var pluginDependencies$i = [
        { name: 'Toolbar' },
        { name: 'SearchState' },
    ];
    var defaultMessages$6 = {
        searchPlaceholder: 'Search...',
    };
    var SearchPanelBase = /*#__PURE__*/ (function (_super) {
        __extends(SearchPanelBase, _super);
        function SearchPanelBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SearchPanelBase.prototype.render = function () {
            var _a = this.props, Input = _a.inputComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$6, messages));
            return (React.createElement(dxReactCore.Plugin, { name: "SearchPanel", dependencies: pluginDependencies$i },
                React.createElement(dxReactCore.Template, { name: "toolbarContent" },
                    React.createElement(dxReactCore.TemplatePlaceholder, null),
                    React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                        var searchValue = _a.searchValue;
                        var changeSearchValue = _b.changeSearchValue;
                        return (React.createElement(Input, { value: searchValue, onValueChange: changeSearchValue, getMessage: getMessage }));
                    }))));
        };
        SearchPanelBase.defaultProps = {
            messages: {},
        };
        SearchPanelBase.components = {
            inputComponent: 'Input',
        };
        return SearchPanelBase;
    }(React.PureComponent));
    /** A plugin that renders the Search Panel. */
    var SearchPanel = SearchPanelBase;

    var tableHeaderRowsComputed$2 = function (_a) {
        var tableHeaderRows = _a.tableHeaderRows;
        return dxGridCore.tableHeaderRowsWithFixed(tableHeaderRows);
    };
    var tableHeaderColumnChainsComputed = function (_a) {
        var tableColumns = _a.tableColumns, tableHeaderRows = _a.tableHeaderRows, tableHeaderColumnChains = _a.tableHeaderColumnChains;
        return dxGridCore.tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows, tableColumns);
    };
    var CellPlaceholder$2 = function (props) { return React.createElement(dxReactCore.TemplatePlaceholder, { params: props }); };
    var pluginDependencies$j = [
        { name: 'Table' },
        { name: 'TableBandHeader', optional: true },
        { name: 'TableColumnReordering', optional: true },
        { name: 'TableEditColumn', optional: true },
        { name: 'TableEditRow', optional: true },
        { name: 'TableFilterRow', optional: true },
        { name: 'TableHeaderRow', optional: true },
        { name: 'TableSelection', optional: true },
        { name: 'TableSummaryRow', optional: true },
        { name: 'TableTreeColumn', optional: true },
    ];
    // tslint:disable-next-line: max-line-length
    var TableFixedColumnsBase = /*#__PURE__*/ (function (_super) {
        __extends(TableFixedColumnsBase, _super);
        function TableFixedColumnsBase(props) {
            var _this = _super.call(this, props) || this;
            _this.state = {
                tableColumnDimensions: {},
            };
            return _this;
        }
        TableFixedColumnsBase.prototype.handleListenerSizeChange = function (key, width) {
            this.setState(function (state) {
                var _a;
                return ({
                    tableColumnDimensions: __assign({}, state.tableColumnDimensions, (_a = {}, _a[key] = width, _a)),
                });
            });
        };
        TableFixedColumnsBase.prototype.render = function () {
            var _this = this;
            var _a = this.props, Cell = _a.cellComponent, ListenerRow = _a.listenerRowComponent, ListenerCell = _a.listenerCellComponent;
            var leftColumns = this.props.leftColumns;
            var rightColumns = this.props.rightColumns;
            var tableColumnsComputed = function (_a) {
                var tableColumns = _a.tableColumns;
                return dxGridCore.tableColumnsWithFixed(tableColumns, leftColumns, rightColumns);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "TableFixedColumns", dependencies: pluginDependencies$j },
                React.createElement(dxReactCore.Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$2 }),
                React.createElement(dxReactCore.Getter, { name: "tableColumns", computed: tableColumnsComputed }),
                React.createElement(dxReactCore.Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableColumn = _a.tableColumn;
                        return !!tableColumn.fixed;
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var tableColumns = _a.tableColumns, tableHeaderColumnChains = _a.tableHeaderColumnChains;
                    var tableColumnDimensions = _this.state.tableColumnDimensions;
                    var fixedColumnProps = dxGridCore.calculateFixedColumnProps(params, { leftColumns: leftColumns, rightColumns: rightColumns }, tableColumns, tableColumnDimensions, tableHeaderColumnChains);
                    return (React.createElement(Cell, __assign({}, params, fixedColumnProps, { component: CellPlaceholder$2 })));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isFixedTableRow(tableRow);
                    } }, function (params) { return (React.createElement(ListenerRow, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isFixedTableRow(tableRow);
                    } }, function (params) { return (React.createElement(ListenerCell, __assign({}, params, { listen: !!params.tableColumn.fixed, onSizeChange: function (_a) {
                        var width = _a.width;
                        return _this.handleListenerSizeChange(params.tableColumn.key, width);
                    } }))); })));
        };
        TableFixedColumnsBase.components = {
            cellComponent: 'Cell',
            listenerRowComponent: 'ListenerRow',
            listenerCellComponent: 'ListenerCell',
        };
        TableFixedColumnsBase.defaultProps = {
            leftColumns: [],
            rightColumns: [],
        };
        return TableFixedColumnsBase;
    }(React.PureComponent));
    /** A plugin that enables you to fix columns to the left and right sides of the grid. */
    var TableFixedColumns = TableFixedColumnsBase;

    var SummaryStateBase = /*#__PURE__*/ (function (_super) {
        __extends(SummaryStateBase, _super);
        function SummaryStateBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SummaryStateBase.prototype.render = function () {
            var _a = this.props, totalItems = _a.totalItems, groupItems = _a.groupItems, treeItems = _a.treeItems;
            return (React.createElement(dxReactCore.Plugin, { name: "SummaryState" },
                React.createElement(dxReactCore.Getter, { name: "totalSummaryItems", value: totalItems }),
                React.createElement(dxReactCore.Getter, { name: "groupSummaryItems", value: groupItems }),
                React.createElement(dxReactCore.Getter, { name: "treeSummaryItems", value: treeItems })));
        };
        return SummaryStateBase;
    }(React.PureComponent));
    /** A plugin that provides items for total, group, and tree summaries. */
    var SummaryState = SummaryStateBase;

    var pluginDependencies$k = [
        { name: 'SummaryState' },
    ];
    var IntegratedSummaryBase = /*#__PURE__*/ (function (_super) {
        __extends(IntegratedSummaryBase, _super);
        function IntegratedSummaryBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        IntegratedSummaryBase.prototype.render = function () {
            var calculator = this.props.calculator;
            var totalSummaryValuesComputed = function (_a) {
                var rows = _a.rows, totalSummaryItems = _a.totalSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getCollapsedRows = _a.getCollapsedRows;
                return dxGridCore.totalSummaryValues(rows, totalSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator);
            };
            var groupSummaryValuesComputed = function (_a) {
                var rows = _a.rows, groupSummaryItems = _a.groupSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow;
                return dxGridCore.groupSummaryValues(rows, groupSummaryItems, getCellValue, getRowLevelKey, isGroupRow, calculator);
            };
            var treeSummaryValuesComputed = function (_a) {
                var rows = _a.rows, treeSummaryItems = _a.treeSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId;
                return dxGridCore.treeSummaryValues(rows, treeSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator);
            };
            return (React.createElement(dxReactCore.Plugin, { name: "IntegratedSummary", dependencies: pluginDependencies$k },
                React.createElement(dxReactCore.Getter, { name: "totalSummaryValues", computed: totalSummaryValuesComputed }),
                React.createElement(dxReactCore.Getter, { name: "groupSummaryValues", computed: groupSummaryValuesComputed }),
                React.createElement(dxReactCore.Getter, { name: "treeSummaryValues", computed: treeSummaryValuesComputed })));
        };
        IntegratedSummaryBase.defaultCalculator = dxGridCore.defaultSummaryCalculator;
        return IntegratedSummaryBase;
    }(React.PureComponent));
    /** A plugin that performs a built-in data summary calculation. */
    var IntegratedSummary = IntegratedSummaryBase;

    var pluginDependencies$l = [
        { name: 'SummaryState' },
    ];
    var CustomSummaryBase = /*#__PURE__*/ (function (_super) {
        __extends(CustomSummaryBase, _super);
        function CustomSummaryBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CustomSummaryBase.prototype.render = function () {
            var _a = this.props, totalValues = _a.totalValues, groupValues = _a.groupValues, treeValues = _a.treeValues;
            return (React.createElement(dxReactCore.Plugin, { name: "CustomSummary", dependencies: pluginDependencies$l },
                React.createElement(dxReactCore.Getter, { name: "totalSummaryValues", value: totalValues }),
                React.createElement(dxReactCore.Getter, { name: "groupSummaryValues", value: groupValues }),
                React.createElement(dxReactCore.Getter, { name: "treeSummaryValues", value: treeValues })));
        };
        return CustomSummaryBase;
    }(React.PureComponent));
    /** A plugin that allows you to calculate a custom summary. */
    var CustomSummary = CustomSummaryBase;

    var dependencies$1 = [
        { name: 'DataTypeProvider', optional: true },
        { name: 'SummaryState' },
        { name: 'CustomSummary', optional: true },
        { name: 'IntegratedSummary', optional: true },
        { name: 'Table' },
        { name: 'TableTreeColumn', optional: true },
    ];
    var defaultMessages$7 = {
        sum: 'Sum',
        min: 'Min',
        max: 'Max',
        avg: 'Avg',
        count: 'Count',
    };
    var tableBodyRowsComputed$2 = function (_a) {
        var tableBodyRows = _a.tableBodyRows, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId;
        return dxGridCore.tableRowsWithSummaries(tableBodyRows, getRowLevelKey, isGroupRow, getRowId);
    };
    var tableFooterRowsComputed = function (_a) {
        var tableFooterRows = _a.tableFooterRows;
        return dxGridCore.tableRowsWithTotalSummaries(tableFooterRows);
    };
    var defaultTypelessSummaries = ['count'];
    var TableSummaryRowBase = /*#__PURE__*/ (function (_super) {
        __extends(TableSummaryRowBase, _super);
        function TableSummaryRowBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TableSummaryRowBase.prototype.renderContent = function (column, columnSummaries) {
            var _a = this.props, formatlessSummaryTypes = _a.formatlessSummaryTypes, Item = _a.itemComponent, messages = _a.messages;
            var getMessage = dxCore.getMessagesFormatter(__assign({}, defaultMessages$7, messages));
            var SummaryItem = function (_a) {
                var summary = _a.summary, children = _a.children;
                return (React.createElement(Item, { getMessage: getMessage, type: summary.type, value: summary.value }, children || String(summary.value)));
            };
            return (React.createElement(React.Fragment, null, columnSummaries.map(function (summary) {
                if (summary.value === null
                    || formatlessSummaryTypes.includes(summary.type)
                    || defaultTypelessSummaries.includes(summary.type)) {
                    return React.createElement(SummaryItem, { key: summary.type, summary: summary });
                }
                return (React.createElement(dxReactCore.TemplatePlaceholder, { key: summary.type, name: "valueFormatter", params: {
                        column: column,
                        value: summary.value,
                    } }, function (content) { return (React.createElement(SummaryItem, { summary: summary }, content)); }));
            })));
        };
        TableSummaryRowBase.prototype.render = function () {
            var _this = this;
            var _a = this.props, TotalRow = _a.totalRowComponent, GroupRow = _a.groupRowComponent, TreeRow = _a.treeRowComponent, TotalCell = _a.totalCellComponent, GroupCell = _a.groupCellComponent, TreeCell = _a.treeCellComponent, TreeColumnCell = _a.treeColumnCellComponent, TreeColumnContent = _a.treeColumnContentComponent, TreeColumnIndent = _a.treeColumnIndentComponent;
            return (React.createElement(dxReactCore.Plugin, { name: "TableSummaryRow", dependencies: dependencies$1 },
                React.createElement(dxReactCore.Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$2 }),
                React.createElement(dxReactCore.Getter, { name: "tableFooterRows", computed: tableFooterRowsComputed }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isTotalSummaryTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var totalSummaryItems = _a.totalSummaryItems, totalSummaryValues = _a.totalSummaryValues;
                    var columnSummaries = dxGridCore.getColumnSummaries(totalSummaryItems, params.tableColumn.column.name, totalSummaryValues);
                    return (React.createElement(TotalCell, __assign({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isGroupSummaryTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var groupSummaryItems = _a.groupSummaryItems, groupSummaryValues = _a.groupSummaryValues;
                    var columnSummaries = dxGridCore.getColumnSummaries(groupSummaryItems, params.tableColumn.column.name, groupSummaryValues[params.tableRow.row.compoundKey]);
                    return (React.createElement(GroupCell, __assign({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                        var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
                        return dxGridCore.isTreeSummaryTableCell(tableRow, tableColumn);
                    } }, function (params) { return (React.createElement(dxReactCore.TemplateConnector, null, function (_a) {
                    var treeSummaryItems = _a.treeSummaryItems, treeSummaryValues = _a.treeSummaryValues, tableTreeColumnName = _a.tableTreeColumnName, getRowId = _a.getRowId, getTreeRowLevel = _a.getTreeRowLevel;
                    var columnSummaries = dxGridCore.getColumnSummaries(treeSummaryItems, params.tableColumn.column.name, treeSummaryValues[getRowId(params.tableRow.row)]);
                    if (tableTreeColumnName === params.tableColumn.column.name) {
                        return (React.createElement(TreeColumnCell, __assign({}, params, { column: params.tableColumn.column }),
                            React.createElement(TreeColumnIndent, { level: getTreeRowLevel(params.tableRow.row) }),
                            React.createElement(TreeColumnContent, null, _this.renderContent(params.tableColumn.column, columnSummaries))));
                    }
                    return (React.createElement(TreeCell, __assign({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries)));
                })); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isTotalSummaryTableRow(tableRow);
                    } }, function (params) { return (React.createElement(TotalRow, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isGroupSummaryTableRow(tableRow);
                    } }, function (params) { return (React.createElement(GroupRow, __assign({}, params))); }),
                React.createElement(dxReactCore.Template, { name: "tableRow", predicate: function (_a) {
                        var tableRow = _a.tableRow;
                        return !!dxGridCore.isTreeSummaryTableRow(tableRow);
                    } }, function (params) { return (React.createElement(TreeRow, __assign({}, params))); })));
        };
        TableSummaryRowBase.TREE_ROW_TYPE = dxGridCore.TABLE_TREE_SUMMARY_TYPE;
        TableSummaryRowBase.GROUP_ROW_TYPE = dxGridCore.TABLE_GROUP_SUMMARY_TYPE;
        TableSummaryRowBase.TOTAL_ROW_TYPE = dxGridCore.TABLE_TOTAL_SUMMARY_TYPE;
        TableSummaryRowBase.defaultProps = {
            formatlessSummaryTypes: [],
            messages: {},
        };
        TableSummaryRowBase.components = {
            totalRowComponent: 'TotalRow',
            groupRowComponent: 'GroupRow',
            treeRowComponent: 'TreeRow',
            totalCellComponent: 'TotalCell',
            groupCellComponent: 'GroupCell',
            treeCellComponent: 'TreeCell',
            treeColumnCellComponent: 'TableTreeCell',
            treeColumnContentComponent: 'TableTreeContent',
            treeColumnIndentComponent: 'TableTreeIndent',
            itemComponent: 'Item',
        };
        return TableSummaryRowBase;
    }(React.PureComponent));
    /** A plugin that renders table rows that display a total, group, and tree summary. */
    var TableSummaryRow = TableSummaryRowBase;

    var virtualRowsComputed = function (_a) {
        var skip = _a.skip, rows = _a.rows, virtualRowsCache = _a.virtualRowsCache;
        return dxGridCore.virtualRowsWithCache(skip, rows, virtualRowsCache);
    };
    var rowsComputed = function (_a) {
        var virtualRows = _a.virtualRows;
        return dxGridCore.plainRows(virtualRows);
    };
    var loadedRowsStartComputed = function (_a) {
        var virtualRows = _a.virtualRows;
        return dxGridCore.loadedRowsStart(virtualRows);
    };
    // tslint:disable-next-line: max-line-length
    var VirtualTableStateBase = /*#__PURE__*/ (function (_super) {
        __extends(VirtualTableStateBase, _super);
        function VirtualTableStateBase(props) {
            var _this = _super.call(this, props) || this;
            _this.requestTimer = 0;
            _this.requestNextPageAction = function (_a, _b) {
                var referenceIndex = _a.referenceIndex, forceReload = _a.forceReload;
                var virtualRows = _b.virtualRows, skip = _b.skip;
                var _c = _this.props, pageSize = _c.pageSize, totalRowCount = _c.totalRowCount;
                var newBounds;
                var requestedRange;
                var actualVirtualRows = virtualRows;
                if (forceReload) {
                    newBounds = requestedRange = { start: skip, end: skip + pageSize * 2 };
                    actualVirtualRows = dxGridCore.emptyVirtualRows;
                }
                else {
                    var loadedInterval = dxGridCore.intervalUtil.getRowsInterval(virtualRows);
                    newBounds = dxGridCore.recalculateBounds(referenceIndex, pageSize, totalRowCount);
                    requestedRange = dxGridCore.calculateRequestedRange(loadedInterval, newBounds, referenceIndex, pageSize);
                }
                var requestedPageIndex = _this.state.requestedPageIndex;
                var newPageIndex = requestedRange.start;
                var loadCount = (requestedRange.end - requestedRange.start);
                var shouldLoadRows = (newPageIndex !== requestedPageIndex && loadCount > 0) || forceReload;
                if (shouldLoadRows) {
                    _this.requestNextPage(newPageIndex, loadCount, actualVirtualRows, newBounds);
                }
            };
            _this.clearRowsCacheAction = function (_, __, _a) {
                var requestNextPage = _a.requestNextPage;
                _this.setState({
                    virtualRowsCache: dxGridCore.emptyVirtualRows,
                });
                requestNextPage({ forceReload: true });
            };
            _this.state = {
                virtualRowsCache: dxGridCore.emptyVirtualRows,
                requestedPageIndex: undefined,
                availableRowCount: props.totalRowCount || 0,
            };
            return _this;
        }
        VirtualTableStateBase.prototype.requestNextPage = function (newPageIndex, loadCount, virtualRows, newBounds) {
            var _this = this;
            var _a = this.props, getRows = _a.getRows, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
            var stateAvailableCount = this.state.availableRowCount;
            if (this.requestTimer !== 0) {
                clearTimeout(this.requestTimer);
            }
            this.requestTimer = window.setTimeout(function () {
                getRows(newPageIndex, loadCount);
                var virtualRowsCache = dxGridCore.trimRowsToInterval(virtualRows, newBounds);
                var newRowCount = infiniteScrolling
                    ? Math.max(newBounds.end + loadCount, stateAvailableCount)
                    : totalRowCount;
                _this.setState({
                    virtualRowsCache: virtualRowsCache,
                    availableRowCount: newRowCount,
                    requestedPageIndex: newPageIndex,
                });
            }, 50);
        };
        VirtualTableStateBase.getDerivedStateFromProps = function (nextProps, prevState) {
            var _a = nextProps.availableRowCount, availableRowCount = _a === void 0 ? prevState.availableRowCount : _a;
            return {
                availableRowCount: availableRowCount,
            };
        };
        VirtualTableStateBase.prototype.componentDidMount = function () {
            var _a = this.props, getRows = _a.getRows, pageSize = _a.pageSize, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
            getRows(0, 2 * pageSize);
            var newRowCount = infiniteScrolling ? 2 * pageSize : totalRowCount;
            this.setState({
                availableRowCount: newRowCount,
            });
        };
        VirtualTableStateBase.prototype.componentWillUnmount = function () {
            if (this.requestTimer !== 0) {
                window.clearTimeout(this.requestTimer);
            }
        };
        VirtualTableStateBase.prototype.render = function () {
            var _a = this.state, virtualRowsCache = _a.virtualRowsCache, stateRowCount = _a.availableRowCount;
            var _b = this.props, skip = _b.skip, pageSize = _b.pageSize, loading = _b.loading, infiniteScrolling = _b.infiniteScrolling, totalRowCount = _b.totalRowCount;
            var availableRowCount = infiniteScrolling ? stateRowCount : totalRowCount;
            return (React.createElement(dxReactCore.Plugin, { name: "VirtualTableState" },
                React.createElement(dxReactCore.Getter, { name: "isDataRemote", value: true }),
                React.createElement(dxReactCore.Getter, { name: "isDataLoading", value: loading }),
                React.createElement(dxReactCore.Getter, { name: "isScrollingInfinite", value: infiniteScrolling }),
                React.createElement(dxReactCore.Getter, { name: "skip", value: skip }),
                React.createElement(dxReactCore.Getter, { name: "virtualRowsCache", value: virtualRowsCache }),
                React.createElement(dxReactCore.Getter, { name: "pageSize", value: pageSize }),
                React.createElement(dxReactCore.Getter, { name: "availableRowCount", value: availableRowCount }),
                React.createElement(dxReactCore.Getter, { name: "virtualRows", computed: virtualRowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "rows", computed: rowsComputed }),
                React.createElement(dxReactCore.Getter, { name: "loadedRowsStart", computed: loadedRowsStartComputed }),
                React.createElement(dxReactCore.Action, { name: "requestNextPage", action: this.requestNextPageAction }),
                React.createElement(dxReactCore.Action, { name: "clearRowCache", action: this.clearRowsCacheAction }),
                React.createElement(dxReactCore.Action, { name: "changeColumnSorting", action: this.clearRowsCacheAction }),
                React.createElement(dxReactCore.Action, { name: "changeColumnFilter", action: this.clearRowsCacheAction })));
        };
        VirtualTableStateBase.defaultProps = {
            pageSize: 100,
        };
        return VirtualTableStateBase;
    }(React.PureComponent));
    var VirtualTableState = VirtualTableStateBase;

    /* globals requestAnimationFrame cancelAnimationFrame */
    var TableLayoutBase = /*#__PURE__*/ (function (_super) {
        __extends(TableLayoutBase, _super);
        function TableLayoutBase(props) {
            var _this = _super.call(this, props) || this;
            _this.savedOffsetWidth = -1;
            _this.raf = -1;
            _this.state = {
                animationState: new Map(),
            };
            _this.animations = new Map();
            _this.savedScrollWidth = {};
            _this.tableRef = React.createRef();
            return _this;
        }
        TableLayoutBase.prototype.componentDidUpdate = function (prevProps) {
            var columns = this.props.columns;
            var prevColumns = prevProps.columns;
            var animationState = this.state.animationState;
            var activeAnimationExists = !dxCore.shallowEqual(columns, prevColumns)
                || !!animationState.size || !!this.animations.size;
            // NOTE: animation should be recomputed only when columns are changed or
            // an active animation is in progress. Otherwise it will be recalculated on
            // each scroll event.
            if (activeAnimationExists) {
                this.processAnimation(prevColumns);
            }
        };
        TableLayoutBase.prototype.processAnimation = function (prevColumns) {
            var columns = this.props.columns;
            var tableWidth = this.getTableWidth(prevColumns, columns);
            this.animations = dxGridCore.getAnimations(prevColumns, columns, tableWidth, this.animations);
            cancelAnimationFrame(this.raf);
            this.raf = requestAnimationFrame(this.processAnimationFrame.bind(this));
        };
        TableLayoutBase.prototype.getTableWidth = function (prevColumns, columns) {
            var _a = this.tableRef.current, offsetWidth = _a.offsetWidth, scrollWidth = _a.scrollWidth;
            var animationState = this.state.animationState;
            var widthChanged = this.savedOffsetWidth !== offsetWidth
                || !this.savedScrollWidth[columns.length];
            var columnCountChanged = columns.length !== prevColumns.length;
            if (columnCountChanged || (widthChanged && !animationState.size)) {
                this.savedScrollWidth = {};
                this.savedScrollWidth[columns.length] = scrollWidth;
                this.savedOffsetWidth = offsetWidth;
            }
            return this.savedScrollWidth[columns.length];
        };
        TableLayoutBase.prototype.getColumns = function () {
            var columns = this.props.columns;
            var animationState = this.state.animationState;
            var result = columns;
            var isFixedWidth = columns.filter(function (column) { return column.width === undefined; }).length === 0;
            if (isFixedWidth) {
                // presumably a flex column added here instead of in a getter in the Table plugin
                // to make sure that all manipulations on taleColumns have already done earlier
                result = __spread(result, [{ key: dxGridCore.TABLE_FLEX_TYPE.toString(), type: dxGridCore.TABLE_FLEX_TYPE }]);
            }
            if (animationState.size) {
                result = result
                    .map(function (column) { return (animationState.has(column.key)
                    ? __assign({}, column, { animationState: animationState.get(column.key) }) : column); });
            }
            return result;
        };
        TableLayoutBase.prototype.processAnimationFrame = function () {
            var animationComponentState = this.state.animationState;
            this.animations = dxGridCore.filterActiveAnimations(this.animations);
            if (!this.animations.size) {
                if (animationComponentState.size) {
                    this.setState({ animationState: new Map() });
                }
                return;
            }
            var animationState = dxGridCore.evalAnimations(this.animations);
            this.setState({ animationState: animationState });
        };
        TableLayoutBase.prototype.render = function () {
            var _a = this.props, Layout = _a.layoutComponent, minColumnWidth = _a.minColumnWidth, restProps = __rest(_a, ["layoutComponent", "minColumnWidth"]);
            var columns = this.getColumns();
            var minWidth = columns
                .map(function (column) { return column.width || (column.type === dxGridCore.TABLE_FLEX_TYPE ? 0 : minColumnWidth); })
                .reduce(function (acc, width) { return acc + width; }, 0);
            return (React.createElement(Layout, __assign({}, restProps, { tableRef: this.tableRef, columns: columns, minWidth: minWidth, minColumnWidth: minColumnWidth })));
        };
        return TableLayoutBase;
    }(React.PureComponent));
    /** @internal */
    var TableLayout = TableLayoutBase;

    /** @internal */
    var ColumnGroup = /*#__PURE__*/ (function (_super) {
        __extends(ColumnGroup, _super);
        function ColumnGroup() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ColumnGroup.prototype.render = function () {
            var columns = this.props.columns;
            return (React.createElement("colgroup", null, columns.map(function (_a) {
                var key = _a.key, width = _a.width;
                return (React.createElement("col", { key: key, style: width !== undefined
                        ? { width: width + "px" }
                        : undefined }));
            })));
        };
        return ColumnGroup;
    }(React.PureComponent));

    var getRowStyle = function (_a) {
        var row = _a.row;
        return (row.height !== undefined
            ? ({ height: row.height + "px" })
            : undefined);
    };

    var VirtualRowLayout = /*#__PURE__*/ (function (_super) {
        __extends(VirtualRowLayout, _super);
        function VirtualRowLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VirtualRowLayout.prototype.shouldComponentUpdate = function (nextProps) {
            var _a = this.props, prevCells = _a.cells, prevRow = _a.row;
            var nextCells = nextProps.cells, nextRow = nextProps.row;
            if (prevRow !== nextRow || prevCells.length !== nextCells.length) {
                return true;
            }
            var propsAreNotEqual = nextCells.some(function (nextCell, i) {
                var prevCell = prevCells[i];
                return prevCell.column !== nextCell.column || prevCell.colSpan !== nextCell.colSpan;
            });
            return propsAreNotEqual;
        };
        VirtualRowLayout.prototype.render = function () {
            var _a = this.props, row = _a.row, cells = _a.cells, Row = _a.rowComponent, Cell = _a.cellComponent;
            return (React.createElement(Row, { tableRow: row, style: getRowStyle({ row: row }) }, cells.map(function (_a) {
                var column = _a.column, colSpan = _a.colSpan;
                return (React.createElement(Cell, { key: column.key, tableRow: row, tableColumn: column, colSpan: colSpan }));
            })));
        };
        return VirtualRowLayout;
    }(React.Component));

    // tslint:disable-next-line: max-line-length
    var VirtualTableLayoutBlock = /*#__PURE__*/ (function (_super) {
        __extends(VirtualTableLayoutBlock, _super);
        function VirtualTableLayoutBlock() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        VirtualTableLayoutBlock.prototype.render = function () {
            var _a = this.props, name = _a.name, tableRef = _a.tableRef, collapsedGrid = _a.collapsedGrid, minWidth = _a.minWidth, blockRefsHandler = _a.blockRefsHandler, rowRefsHandler = _a.rowRefsHandler, Table = _a.tableComponent, Body = _a.bodyComponent, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent, marginBottom = _a.marginBottom;
            return (React.createElement(dxReactCore.RefHolder, { ref: function (ref) { return blockRefsHandler(name, ref); } },
                React.createElement(Table, { tableRef: tableRef, style: __assign({ minWidth: minWidth + "px" }, marginBottom ? { marginBottom: marginBottom + "px" } : null) },
                    React.createElement(ColumnGroup, { columns: collapsedGrid.columns }),
                    React.createElement(Body, null, collapsedGrid.rows.map(function (visibleRow) {
                        var row = visibleRow.row, _a = visibleRow.cells, cells = _a === void 0 ? [] : _a;
                        return (React.createElement(dxReactCore.RefHolder, { key: row.key, ref: function (ref) { return rowRefsHandler(row, ref); } },
                            React.createElement(VirtualRowLayout, { row: row, cells: cells, rowComponent: rowComponent, cellComponent: cellComponent })));
                    })))));
        };
        VirtualTableLayoutBlock.defaultProps = {
            blockRefsHandler: function () { },
            rowRefsHandler: function () { },
            tableRef: React.createRef(),
        };
        return VirtualTableLayoutBlock;
    }(React.PureComponent));

    var AUTO_HEIGHT = 'auto';
    var defaultProps$3 = {
        headerRows: [],
        footerRows: [],
        headComponent: function () { return null; },
        headTableComponent: function () { return null; },
        footerComponent: function () { return null; },
        footerTableComponent: function () { return null; },
        ensureNextVirtualPage: function () { return void 0; },
    };
    /** @internal */
    // tslint:disable-next-line: max-line-length
    var VirtualTableLayout = /*#__PURE__*/ (function (_super) {
        __extends(VirtualTableLayout, _super);
        function VirtualTableLayout(props) {
            var _this = _super.call(this, props) || this;
            _this.rowRefs = new Map();
            _this.blockRefs = new Map();
            _this.isEdgeBrowser = false;
            _this.getRowHeight = function (row) {
                var rowHeights = _this.state.rowHeights;
                var estimatedRowHeight = _this.props.estimatedRowHeight;
                if (row) {
                    var storedHeight = rowHeights.get(row.key);
                    if (storedHeight !== undefined)
                        return storedHeight;
                    if (row.height)
                        return row.height;
                }
                return estimatedRowHeight;
            };
            _this.registerRowRef = function (row, ref) {
                if (ref === null) {
                    _this.rowRefs.delete(row);
                }
                else {
                    _this.rowRefs.set(row, ref);
                }
            };
            _this.registerBlockRef = function (name, ref) {
                if (ref === null) {
                    _this.blockRefs.delete(name);
                }
                else {
                    _this.blockRefs.set(name, ref);
                }
            };
            _this.updateViewport = function (e, visibleRowBoundaries, ensureNextVirtualPage) {
                var node = e.target;
                if (_this.shouldSkipScrollEvent(e)) {
                    return;
                }
                var estimatedRowHeight = _this.props.estimatedRowHeight;
                var containerHeight = _this.state.containerHeight;
                var viewportTop = node.scrollTop, viewportLeft = node.scrollLeft;
                ensureNextVirtualPage({
                    estimatedRowHeight: estimatedRowHeight,
                    visibleRowBoundaries: visibleRowBoundaries,
                    viewportTop: viewportTop,
                    containerHeight: containerHeight,
                });
                _this.setState({
                    viewportTop: viewportTop,
                    viewportLeft: viewportLeft,
                });
            };
            _this.handleContainerSizeChange = function (_a) {
                var width = _a.width, height = _a.height;
                _this.setState({ containerWidth: width, containerHeight: height });
            };
            _this.state = {
                rowHeights: new Map(),
                viewportTop: 0,
                viewportLeft: 0,
                containerWidth: 800,
                containerHeight: 600,
                height: 0,
                headerHeight: 0,
                bodyHeight: 0,
                footerHeight: 0,
            };
            var headerHeight = props.headerRows
                .reduce(function (acc, row) { return acc + _this.getRowHeight(row); }, 0);
            var footerHeight = props.footerRows
                .reduce(function (acc, row) { return acc + _this.getRowHeight(row); }, 0);
            _this.state = __assign({ headerHeight: headerHeight,
                footerHeight: footerHeight }, _this.state);
            _this.getColumnWidthGetter = dxCore.memoize(function (tableColumns, tableWidth, minColumnWidth) { return (dxGridCore.getColumnWidthGetter(tableColumns, tableWidth, minColumnWidth)); });
            return _this;
        }
        VirtualTableLayout.prototype.componentDidMount = function () {
            this.isEdgeBrowser = dxCore.isEdgeBrowser();
            this.storeRowHeights();
            this.storeBlockHeights();
        };
        VirtualTableLayout.prototype.componentDidUpdate = function () {
            this.storeRowHeights();
            this.storeBlockHeights();
        };
        VirtualTableLayout.getDerivedStateFromProps = function (nextProps, prevState) {
            var prevRowHeight = prevState.rowHeights;
            var rowHeights = __spread(nextProps.headerRows, nextProps.bodyRows, nextProps.footerRows).reduce(function (acc, row) {
                var rowHeight = prevRowHeight.get(row.key);
                if (rowHeight !== undefined) {
                    acc.set(row.key, rowHeight);
                }
                return acc;
            }, new Map());
            return { rowHeights: rowHeights };
        };
        VirtualTableLayout.prototype.storeRowHeights = function () {
            var _this = this;
            var rowsWithChangedHeights = Array.from(this.rowRefs.entries())
                .map(function (_a) {
                var _b = __read(_a, 2), row = _b[0], ref = _b[1];
                return [row, reactDom.findDOMNode(ref)];
            })
                .filter(function (_a) {
                var _b = __read(_a, 2), node = _b[1];
                return !!node;
            })
                .map(function (_a) {
                var _b = __read(_a, 2), row = _b[0], node = _b[1];
                return [row, node.getBoundingClientRect().height];
            })
                .filter(function (_a) {
                var _b = __read(_a, 1), row = _b[0];
                return row.type !== dxGridCore.TABLE_STUB_TYPE;
            })
                .filter(function (_a) {
                var _b = __read(_a, 2), row = _b[0], height = _b[1];
                return height !== _this.getRowHeight(row);
            });
            if (rowsWithChangedHeights.length) {
                var rowHeights_1 = this.state.rowHeights;
                rowsWithChangedHeights
                    .forEach(function (_a) {
                    var _b = __read(_a, 2), row = _b[0], height = _b[1];
                    return rowHeights_1.set(row.key, height);
                });
                this.setState({
                    rowHeights: rowHeights_1,
                });
            }
        };
        VirtualTableLayout.prototype.storeBlockHeights = function () {
            var _this = this;
            var getBlockHeight = function (blockName) { return (_this.blockRefs.get(blockName)
                ? reactDom.findDOMNode(_this.blockRefs.get(blockName)).getBoundingClientRect().height
                : 0); };
            var headerHeight = getBlockHeight('header');
            var bodyHeight = getBlockHeight('body');
            var footerHeight = getBlockHeight('footer');
            var _a = this.state, prevHeaderHeight = _a.headerHeight, prevBodyHeight = _a.bodyHeight, prevFooterHeight = _a.footerHeight;
            if (prevHeaderHeight !== headerHeight
                || prevBodyHeight !== bodyHeight
                || prevFooterHeight !== footerHeight) {
                this.setState({
                    headerHeight: headerHeight,
                    bodyHeight: bodyHeight,
                    footerHeight: footerHeight,
                });
            }
        };
        VirtualTableLayout.prototype.shouldSkipScrollEvent = function (e) {
            var node = e.target;
            // NOTE: prevent nested scroll to update viewport
            if (node !== e.currentTarget) {
                return true;
            }
            // NOTE: prevent iOS to flicker in bounces and correct rendering on high dpi screens
            var correction = this.isEdgeBrowser ? 1 : 0;
            var nodeHorizontalOffset = parseInt(node.scrollLeft + node.clientWidth, 10) - correction;
            var nodeVerticalOffset = parseInt(node.scrollTop + node.clientHeight, 10) - correction;
            if (node.scrollTop < 0
                || node.scrollLeft < 0
                || nodeHorizontalOffset > Math.max(node.scrollWidth, node.clientWidth)
                || nodeVerticalOffset > Math.max(node.scrollHeight, node.clientHeight)) {
                return true;
            }
            return false;
        };
        VirtualTableLayout.prototype.getVisibleBoundaries = function () {
            var _a = this.props, loadedRowsStart = _a.loadedRowsStart, bodyRows = _a.bodyRows, headerRows = _a.headerRows, footerRows = _a.footerRows, estimatedRowHeight = _a.estimatedRowHeight;
            return dxGridCore.getVisibleRowsBounds(this.state, { loadedRowsStart: loadedRowsStart, bodyRows: bodyRows, headerRows: headerRows, footerRows: footerRows }, estimatedRowHeight, this.getRowHeight);
        };
        VirtualTableLayout.prototype.getCollapsedGrids = function (visibleRowBoundaries) {
            var _a = this.state, viewportLeft = _a.viewportLeft, containerWidth = _a.containerWidth;
            var _b = this.props, headerRows = _b.headerRows, bodyRows = _b.bodyRows, footerRows = _b.footerRows, columns = _b.columns, loadedRowsStart = _b.loadedRowsStart, totalRowCount = _b.totalRowCount, getCellColSpan = _b.getCellColSpan, minColumnWidth = _b.minColumnWidth;
            var getColumnWidth = this.getColumnWidthGetter(columns, containerWidth, minColumnWidth);
            return dxGridCore.getCollapsedGrids({
                headerRows: headerRows,
                bodyRows: bodyRows,
                footerRows: footerRows,
                columns: columns,
                loadedRowsStart: loadedRowsStart,
                totalRowCount: totalRowCount,
                getCellColSpan: getCellColSpan,
                viewportLeft: viewportLeft,
                containerWidth: containerWidth,
                visibleRowBoundaries: visibleRowBoundaries,
                getColumnWidth: getColumnWidth,
                getRowHeight: this.getRowHeight,
            });
        };
        VirtualTableLayout.prototype.render = function () {
            var _this = this;
            var _a = this.props, Container = _a.containerComponent, HeadTable = _a.headTableComponent, FootTable = _a.footerTableComponent, Table = _a.tableComponent, Head = _a.headComponent, Body = _a.bodyComponent, Footer = _a.footerComponent, tableRef = _a.tableRef, height = _a.height, headerRows = _a.headerRows, footerRows = _a.footerRows, ensureNextVirtualPage = _a.ensureNextVirtualPage, minColumnWidth = _a.minColumnWidth, minWidth = _a.minWidth, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent;
            var _b = this.state, containerHeight = _b.containerHeight, headerHeight = _b.headerHeight, bodyHeight = _b.bodyHeight, footerHeight = _b.footerHeight;
            var visibleRowBoundaries = this.getVisibleBoundaries();
            var collapsedGrids = this.getCollapsedGrids(visibleRowBoundaries);
            var commonProps = {
                cellComponent: cellComponent,
                rowComponent: rowComponent,
                minColumnWidth: minColumnWidth,
                minWidth: minWidth,
                blockRefsHandler: this.registerBlockRef,
                rowRefsHandler: this.registerRowRef,
            };
            return (React.createElement(dxReactCore.Sizer, { onSizeChange: this.handleContainerSizeChange, containerComponent: Container, style: __assign({}, (height === AUTO_HEIGHT ? null : { height: height })), onScroll: function (e) { return _this.updateViewport(e, visibleRowBoundaries, ensureNextVirtualPage); } },
                (!!headerRows.length) && (React.createElement(VirtualTableLayoutBlock, __assign({}, commonProps, { name: "header", collapsedGrid: collapsedGrids.headerGrid, tableComponent: HeadTable, bodyComponent: Head }))),
                React.createElement(VirtualTableLayoutBlock, __assign({}, commonProps, { name: "body", collapsedGrid: collapsedGrids.bodyGrid, tableComponent: Table, bodyComponent: Body, tableRef: tableRef, marginBottom: Math.max(0, containerHeight - headerHeight - bodyHeight - footerHeight) })),
                (!!footerRows.length) && (React.createElement(VirtualTableLayoutBlock, __assign({}, commonProps, { name: "footer", collapsedGrid: collapsedGrids.footerGrid, tableComponent: FootTable, bodyComponent: Footer })))));
        };
        VirtualTableLayout.defaultProps = defaultProps$3;
        return VirtualTableLayout;
    }(React.PureComponent));

    var getColumnStyle = function (_a) {
        var column = _a.column;
        return column.animationState;
    };
    /** @internal */
    var RowLayout = /*#__PURE__*/ (function (_super) {
        __extends(RowLayout, _super);
        function RowLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RowLayout.prototype.render = function () {
            var _a = this.props, row = _a.row, columns = _a.columns, Row = _a.rowComponent, Cell = _a.cellComponent, getCellColSpan = _a.getCellColSpan;
            var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
            return (React.createElement(Row, { tableRow: row, style: getRowStyle({ row: row }) }, columns
                .map(function (column) { return (React.createElement(Cell, { key: column.key, tableRow: row, tableColumn: column, style: getColumnStyle({ column: column }), colSpan: getColSpan(row, column) })); })));
        };
        return RowLayout;
    }(React.PureComponent));

    /** @internal */
    var RowsBlockLayout = /*#__PURE__*/ (function (_super) {
        __extends(RowsBlockLayout, _super);
        function RowsBlockLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RowsBlockLayout.prototype.render = function () {
            var _a = this.props, rows = _a.rows, columns = _a.columns, Block = _a.blockComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan;
            return (React.createElement(Block, null, rows
                .map(function (row) { return (React.createElement(RowLayout, { key: row.key, row: row, columns: columns, rowComponent: rowComponent, cellComponent: cellComponent, getCellColSpan: getCellColSpan })); })));
        };
        return RowsBlockLayout;
    }(React.PureComponent));

    var defaultProps$4 = {
        headerRows: [],
        footerRows: [],
        headComponent: function () { return null; },
        footerComponent: function () { return null; },
    };
    /** @internal */
    var StaticTableLayout = /*#__PURE__*/ (function (_super) {
        __extends(StaticTableLayout, _super);
        function StaticTableLayout() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StaticTableLayout.prototype.render = function () {
            var _a = this.props, headerRows = _a.headerRows, bodyRows = _a.bodyRows, footerRows = _a.footerRows, columns = _a.columns, minWidth = _a.minWidth, Container = _a.containerComponent, Table = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan, tableRef = _a.tableRef;
            var commonProps = {
                columns: columns,
                rowComponent: rowComponent,
                cellComponent: cellComponent,
                getCellColSpan: getCellColSpan,
            };
            return (React.createElement(Container, null,
                React.createElement(Table, { tableRef: tableRef, style: { minWidth: minWidth + "px" } },
                    React.createElement(ColumnGroup, { columns: columns }),
                    !!headerRows.length && (React.createElement(RowsBlockLayout, __assign({ rows: headerRows, blockComponent: headComponent }, commonProps))),
                    React.createElement(RowsBlockLayout, __assign({ rows: bodyRows, blockComponent: bodyComponent }, commonProps)),
                    !!footerRows.length && (React.createElement(RowsBlockLayout, __assign({ rows: footerRows, blockComponent: footerComponent }, commonProps))))));
        };
        StaticTableLayout.defaultProps = defaultProps$4;
        return StaticTableLayout;
    }(React.PureComponent));

    var RemoteDataLoader = /*#__PURE__*/ (function (_super) {
        __extends(RemoteDataLoader, _super);
        function RemoteDataLoader() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.ensureNextVirtualPage = function (payload, getters, _a) {
                var requestNextPage = _a.requestNextPage;
                var isDataRemote = getters.isDataRemote;
                if (!isDataRemote) {
                    return;
                }
                var referenceIndex = dxGridCore.nextPageReferenceIndex(payload, getters);
                if (referenceIndex !== null) {
                    requestNextPage({ referenceIndex: referenceIndex });
                }
            };
            return _this;
        }
        RemoteDataLoader.prototype.render = function () {
            return (React.createElement(dxReactCore.Plugin, { name: "RemoteDataLoader" },
                React.createElement(dxReactCore.Action, { name: "ensureNextVirtualPage", action: this.ensureNextVirtualPage })));
        };
        return RemoteDataLoader;
    }(React.PureComponent));

    /** @internal */
    var makeVirtualTable = function (Table, _a) {
        var VirtualLayout = _a.VirtualLayout, FixedHeader = _a.FixedHeader, FixedFooter = _a.FixedFooter, SkeletonCell = _a.SkeletonCell, defaultEstimatedRowHeight = _a.defaultEstimatedRowHeight, defaultHeight = _a.defaultHeight;
        var VirtualTable = /*#__PURE__*/ (function (_super) {
            __extends(VirtualTable, _super);
            function VirtualTable(props) {
                var _this = _super.call(this, props) || this;
                _this.layoutRenderComponent = dxReactCore.connectProps(VirtualLayout, function () {
                    var _a = _this.props, headTableComponent = _a.headTableComponent, footerTableComponent = _a.footerTableComponent;
                    return {
                        headTableComponent: headTableComponent,
                        footerTableComponent: footerTableComponent,
                    };
                });
                return _this;
            }
            VirtualTable.prototype.componentDidUpdate = function () {
                this.layoutRenderComponent.update();
            };
            VirtualTable.prototype.render = function () {
                var _a = this.props, height = _a.height, estimatedRowHeight = _a.estimatedRowHeight, SkeletonStubCell = _a.skeletonCellComponent, children = _a.children, restProps = __rest(_a, ["height", "estimatedRowHeight", "skeletonCellComponent", "children"]);
                return (React.createElement(dxReactCore.Plugin, { name: "VirtualTable" },
                    React.createElement(Table, __assign({ layoutComponent: this.layoutRenderComponent }, restProps)),
                    React.createElement(RemoteDataLoader, null),
                    React.createElement(dxReactCore.Template, { name: "tableLayout" }, function (params) {
                        return (React.createElement(dxReactCore.TemplateConnector, null, function (_a, _b) {
                            var availableRowCount = _a.availableRowCount, loadedRowsStart = _a.loadedRowsStart, tableBodyRows = _a.tableBodyRows;
                            var ensureNextVirtualPage = _b.ensureNextVirtualPage;
                            var totalRowCount = availableRowCount || tableBodyRows.length;
                            return (React.createElement(dxReactCore.TemplatePlaceholder, { params: __assign({}, params, { totalRowCount: totalRowCount,
                                    loadedRowsStart: loadedRowsStart,
                                    height: height,
                                    estimatedRowHeight: estimatedRowHeight,
                                    ensureNextVirtualPage: ensureNextVirtualPage }) }));
                        }));
                    }),
                    React.createElement(dxReactCore.Template, { name: "tableCell", predicate: function (_a) {
                            var tableRow = _a.tableRow;
                            return !!dxGridCore.isStubTableCell(tableRow);
                        } }, function (params) { return (React.createElement(SkeletonStubCell, __assign({}, params))); })));
            };
            VirtualTable.defaultProps = {
                estimatedRowHeight: defaultEstimatedRowHeight,
                height: defaultHeight,
                headTableComponent: FixedHeader,
                footerTableComponent: FixedFooter,
                skeletonCellComponent: SkeletonCell,
            };
            return VirtualTable;
        }(React.PureComponent));
        Object.values(Table.components).forEach(function (name) {
            VirtualTable[name] = Table[name];
        });
        VirtualTable.FixedHeader = FixedHeader;
        VirtualTable.FixedFooter = FixedFooter;
        VirtualTable.SkeletonCell = SkeletonCell;
        return VirtualTable;
    };

    var Node = /*#__PURE__*/ (function () {
        function Node(start, rows) {
            this.prev = null;
            this.next = null;
            this.start = start;
            this.rows = rows;
        }
        return Node;
    }());
    // tslint:disable-next-line:max-classes-per-file
    var LRUCache = /*#__PURE__*/ (function () {
        function LRUCache(pageSize, capacity) {
            if (capacity === void 0) { capacity = Number.POSITIVE_INFINITY; }
            this.pages = new Map();
            this.pageSize = pageSize;
            this.capacity = capacity;
            this.initList();
        }
        LRUCache.prototype.initList = function () {
            this.head = new Node(-1, []);
            this.tail = new Node(-1, []);
            this.head.next = this.tail;
            this.tail.prev = this.head;
        };
        LRUCache.prototype.addPage = function (pageStart, rows) {
            if (this.pages.has(pageStart)) {
                this.removePage(pageStart);
            }
            var node = new Node(pageStart, rows);
            var last = this.tail.prev;
            last.next = node;
            node.next = this.tail;
            node.prev = last;
            this.tail.prev = node;
            this.pages.set(pageStart, node);
            if (this.pages.size > this.capacity) {
                this.removePage(this.head.next.start);
            }
        };
        LRUCache.prototype.removePage = function (start) {
            var node = this.pages.get(start);
            node.prev.next = node.next;
            node.next.prev = node.prev;
            this.pages.delete(start);
        };
        LRUCache.prototype.getPage = function (pageStart) {
            if (!this.pages.has(pageStart)) {
                return null;
            }
            var rows = this.pages.get(pageStart).rows;
            this.removePage(pageStart);
            this.addPage(pageStart, rows);
            return rows;
        };
        LRUCache.prototype.clear = function () {
            this.pages.clear();
            this.initList();
        };
        return LRUCache;
    }());
    var createRowCache = function (pageSize, capacity) {
        if (capacity === void 0) { capacity = Number.POSITIVE_INFINITY; }
        var cache = new LRUCache(pageSize, capacity / pageSize);
        return {
            getRows: function (skip, count) {
                var result = [];
                var pageCount = Math.ceil(count / pageSize);
                for (var i = 0; i < pageCount; i += 1) {
                    var pageStart = skip + i * pageSize;
                    var chunk = cache.getPage(pageStart);
                    // add incomplete page to result only if it is last one
                    if (chunk === null || (i !== pageCount - 1 && chunk.length !== pageSize)) {
                        return result;
                    }
                    result = result.concat(chunk);
                }
                return result;
            },
            setRows: function (skip, rows) {
                var pageCount = Math.ceil(rows.length / pageSize);
                for (var i = 0; i < pageCount; i += 1) {
                    var pageStart = i * pageSize;
                    var rowsChunk = rows.slice(pageStart, pageStart + pageSize);
                    // put incomplete page only if it is last one
                    if (rowsChunk.length === pageSize || i === pageCount - 1) {
                        cache.addPage(pageStart + skip, rowsChunk);
                    }
                }
            },
            invalidate: function () { return cache.clear(); },
        };
    };

    exports.ColumnChooser = ColumnChooser;
    exports.CustomGrouping = CustomGrouping;
    exports.CustomPaging = CustomPaging;
    exports.CustomSummary = CustomSummary;
    exports.CustomTreeData = CustomTreeData;
    exports.DataTypeProvider = DataTypeProvider;
    exports.DragDropProvider = DragDropProvider;
    exports.EditingState = EditingState;
    exports.FilteringState = FilteringState;
    exports.Grid = Grid;
    exports.GroupPanelLayout = GroupPanelLayout;
    exports.GroupingPanel = GroupingPanel;
    exports.GroupingState = GroupingState;
    exports.IntegratedFiltering = IntegratedFiltering;
    exports.IntegratedGrouping = IntegratedGrouping;
    exports.IntegratedPaging = IntegratedPaging;
    exports.IntegratedSelection = IntegratedSelection;
    exports.IntegratedSorting = IntegratedSorting;
    exports.IntegratedSummary = IntegratedSummary;
    exports.PagingPanel = PagingPanel;
    exports.PagingState = PagingState;
    exports.RowDetailState = RowDetailState;
    exports.SearchPanel = SearchPanel;
    exports.SearchState = SearchState;
    exports.SelectionState = SelectionState;
    exports.SortingState = SortingState;
    exports.StaticTableLayout = StaticTableLayout;
    exports.SummaryState = SummaryState;
    exports.Table = Table;
    exports.TableBandHeader = TableBandHeader;
    exports.TableColumnReordering = TableColumnReordering;
    exports.TableColumnResizing = TableColumnResizing;
    exports.TableColumnVisibility = TableColumnVisibility;
    exports.TableEditColumn = TableEditColumn;
    exports.TableEditRow = TableEditRow;
    exports.TableFilterRow = TableFilterRow;
    exports.TableFixedColumns = TableFixedColumns;
    exports.TableGroupRow = TableGroupRow;
    exports.TableHeaderRow = TableHeaderRow;
    exports.TableLayout = TableLayout;
    exports.TableRowDetail = TableRowDetail;
    exports.TableSelection = TableSelection;
    exports.TableSummaryRow = TableSummaryRow;
    exports.TableTreeColumn = TableTreeColumn;
    exports.Toolbar = Toolbar;
    exports.TreeDataState = TreeDataState;
    exports.VirtualTableLayout = VirtualTableLayout;
    exports.VirtualTableState = VirtualTableState;
    exports.createRowCache = createRowCache;
    exports.makeVirtualTable = makeVirtualTable;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=dx-react-grid.umd.js.map
